<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[性能优化之十四使Ajax可缓存]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8D%81%E5%9B%9B%E4%BD%BFAjax%E5%8F%AF%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>Ajax 是 DHTML 中使用的一项技术，客户端可以获取和显示用户请求的新信息而无需重新加载页面。</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax 不是一个单独的、需要许可证的技术，而是一组技术，包括 Javascript、 CSS、 DOM 和异步数据获取。 Ajax 的目的是为了突破 Web 本质的开始-停止交互方式。它将 Web 体验从 “浏览页面” 转变为 “与应用程序进行交互”。</p>
<h2 id="异步与即时"><a href="#异步与即时" class="headerlink" title="异步与即时"></a>异步与即时</h2><p>用户是否需要等待的关键因素在于 Ajax 请求时被动的还是主动的。<br>被动请求： 是为了将来使用而预先发起的。<br>主动请求： 是基于用户当前的操作而发起的。<br>Ajax优点： </p>
<ul>
<li>用户不必忍受整个页面的重新加载了</li>
<li>当用户等待时， UI 仍然是可响应的</li>
</ul>
<p>注意： 用户在进行进一步操作之前仍可能需要坐在那里，等待搜索结果显示出来，”异步” 并没有暗示”即时”。</p>
<h2 id="优化-Ajax-请求"><a href="#优化-Ajax-请求" class="headerlink" title="优化 Ajax 请求"></a>优化 Ajax 请求</h2><p>当发起主动 Ajax 请求时，用户可能仍须等待。优化主动 Ajax 请求的技术同样适用于被动 Ajax 请求，但主动请求对用户体验的影响更大。<br>改善这些主动 Ajax 请求最重要的方式就是使响应可缓存（最重要的改进方法），如下这些规则也适用于优化 Ajax 请求：</p>
<ul>
<li>规则4——压缩组件</li>
<li>规则9——减少 DNS 查找</li>
<li>规则10——精简 Javascript</li>
<li>规则11——避免重定向</li>
<li>规则13—— ETag——用还是不用</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>使 Ajax 请求可缓存，除了改变 HTTP 头之外还需要进行更多的工作。响应的<strong>个性化和动态本质</strong>必须被反映到缓存中。可供采用的最好的方式是使用<strong>查询字符串参数</strong>。<br>例如：</p>
<pre><code>/ws/mail/vl/formrpc?m=GetMessage&amp;yid=steve_souders
</code></pre><p>确保产生变化后不会再使用缓存的请求，简单的解决方法还是使用查询字符串。例如可以用时间戳来代表资源末次修改发生的时间，并将其嵌入到 Ajax 请求查询的字符串中欧： </p>
<pre><code>/ar?id=[snip...]&amp;srow=0&amp;erow=100&amp;t=1177458941
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之十三配置ETag]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8D%81%E4%B8%89%E9%85%8D%E7%BD%AEETag/</url>
      <content type="html"><![CDATA[<p>减少呈现页面时所必需的 HTTP 请求数量是加速用户体验的最佳方式。 可以通过最大化浏览器缓存组件的能力来实现这一目标，但当网站被宿主存在多于一台服务器上时， ETag 头可能会阻碍缓存。</p>
<h2 id="ETag-是什么？"><a href="#ETag-是什么？" class="headerlink" title="ETag 是什么？"></a>ETag 是什么？</h2><p>实体标签是 Web 服务器和浏览器用于确认缓存组件有效性的一种机制。</p>
<h3 id="Expires-头"><a href="#Expires-头" class="headerlink" title="Expires 头"></a>Expires 头</h3><p>Web 服务器使用 Expires 头来告诉 Web 客户端它可以使用一个组件的当前副本，直到指定的时间为止。<br>注意： Expires 头指定缓存是否有效，用的是时间标识的。</p>
<h3 id="条件-GET-请求"><a href="#条件-GET-请求" class="headerlink" title="条件 GET 请求"></a>条件 GET 请求</h3><p>如果缓存的组件过期了（或者用户明确地重新加载了页面），浏览器在重用它之前必须首先检查它是否仍然有效。<br>服务器在检测缓存的组件是否和原始服务器上的组件匹配时有两种方式： </p>
<ul>
<li>比较最新修改日期</li>
<li>比较实体标签</li>
</ul>
<h3 id="最新修改日期"><a href="#最新修改日期" class="headerlink" title="最新修改日期"></a>最新修改日期</h3><p>原始服务器通过 Last-Modified 响应头来返回组件的最新修改日期。<br>第一次请求，浏览器缓存了组件以及他的最新修改日期（Last-Modified）。下一次请求，浏览器会使用 If-Modified-Since 头将最新修改日期传回到原始服务器进行比较，如果原始服务器上组件的最新修改日期与浏览器传回的值匹配，会返回以个304响应。</p>
<h3 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h3><p>ETag 提供除 Expires 头之外的一种检测浏览器缓存中的组件与原始服务器上的组件是否匹配的方式。<br>ETag 是唯一标识了一个组件的一个特定版本的字符串。唯一的格式约束是该字符串必须用引号引起来。<br>原始服务器使用 ETag 响应头来指定组件的 ETag。<br><strong>注意</strong>： ETag 头的优先级比 Expires 头的优先级高（我理解的是： 因为 ETag　标识的信息比　Expires头多）！！！意味着设置长时间的 Expires 头还是需要看 Etag 脸色行事的。</p>
<h2 id="ETag-带来的问题"><a href="#ETag-带来的问题" class="headerlink" title="ETag 带来的问题"></a>ETag 带来的问题</h2><p>ETag 的问题在于，通常使用组件的某些属性（大小、时间戳）来构造它，这些属性对于特定的、寄宿了网站的服务器来说是唯一的。但对于拥有多台服务器（服务器集群）的网站，Apache 和 IIS 向 ETag 中嵌入的数据都会大大地降低有效性验证的成功率（用户就不会受到 304 响应，相反会受到普通的 200 响应以及组件的所有数据）。<br>原因： Apache 1.3 和 2.x 的 ETag 格式是 inode-size-timestamp; IIS 5.0 和 6.0 的 ETag 的格式是 Filetimestamp: ChangeNumber。<br>文件系统使用 inode 来存储诸如文件类型、所有者、组合访问模式等信息。多台服务器之间的 inode 是不同的。 ChangeNumber 适用于跟踪 IIS 配置变化的计数器，对于多台 IIS 服务器来说， ChangeNumber 是不同的</p>
<h2 id="ETag-——用还是不用"><a href="#ETag-——用还是不用" class="headerlink" title="ETag ——用还是不用"></a>ETag ——用还是不用</h2><p>如果在多台服务器上寄宿你的网站，而且使用的是默认 ETag 配置的 Apache 或 IIS，则会由于 ETag 不匹配带来的诸多问题（用户面对缓慢的页面、服务器负载高、消耗大量的带宽且代理也不能有效的缓存内容）， 就算你配置了长久的 Expires 头，还是无法避免条件 GET 请求， 因为我们的 ETag 是大佬，Expires头是小弟，如果 ETag 不匹配获得的是缓慢的 200 响应，匹配那么获得的就是 304。</p>
<p>解决方案： </p>
<ul>
<li>对 ETag 进行配置，以利用其灵活的验证能力（如果你的组件必须通过最新修改日期之外的一些东西来进行验证，则 ETag 是一种强大的方法）</li>
<li>如果无须自定义 ETag，最好简单地将其移除， Apache 和 IIS 都将 ETag 视为一个性能问题，并建议修改 ETag 的内容。</li>
</ul>
<p>总结： 要么配置 ETag 要么移除 ETag</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="./rule13.1.png" alt="alt txt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化十二之删除重复脚本]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8D%81%E4%BA%8C%E4%B9%8B%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>在一个页面中两次包含同一个 Javascript 文件会损伤性能。</p>
<h2 id="重复脚本"><a href="#重复脚本" class="headerlink" title="重复脚本"></a>重复脚本</h2><p>导致一个脚本重复又两个主要因素——团队大小和脚本数量。</p>
<h2 id="重复脚本损伤性能"><a href="#重复脚本损伤性能" class="headerlink" title="重复脚本损伤性能"></a>重复脚本损伤性能</h2><p>重复脚本损伤性能的方式有两种： </p>
<ul>
<li>不必要的 HTTP 请求</li>
<li>执行 Javascript 所浪费的时间</li>
</ul>
<p>总体来说： </p>
<ul>
<li>在页面中多次包含相同的脚本会使页面变慢</li>
<li>在 IE 中，如果脚本没有被缓存，或在重新加载页面时，会产生额外的 HTTP 请求。</li>
<li>在 Firefox 和 IE 中，脚本会被多次求值。</li>
</ul>
<h2 id="避免重复脚本"><a href="#避免重复脚本" class="headerlink" title="避免重复脚本"></a>避免重复脚本</h2><p>避免意外包含同一个脚本两次的一种方法是，在你的模板系统中实现一个脚本管理模块。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之十一避免重定向]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8D%81%E4%B8%80%E9%81%BF%E5%85%8D%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      <content type="html"><![CDATA[<p>重定向: 用于将用户从一个 URL 重新路由到另一个 URL。<br>实现重定向有很多原因：</p>
<ul>
<li>网站重新设计</li>
<li>跟踪流量</li>
<li>记录广告点击</li>
<li>建立易于记忆的 URL</li>
</ul>
<p>重定向缺陷： 会使页面变慢</p>
<h2 id="重定向类型"><a href="#重定向类型" class="headerlink" title="重定向类型"></a>重定向类型</h2><p>重定向有很多种，最常见的是：</p>
<ul>
<li>301 Moved Permancently</li>
<li>302 Moved Temporarily (亦称 Found)</li>
</ul>
<p>301 和 302 响应头中（Response Headers）会返回一个 Location 字段，浏览器会自动将用户带到 Location 字段给出的 URL。重定向所必需的所有信息都出现在这个头中了。301 和 302 响应在实际中都不会被缓存，除非有附加的头—— 如 Expores 或 Cache-Control 等 ——要求它这么做。  </p>
<h3 id="其他重定向方法"><a href="#其他重定向方法" class="headerlink" title="其他重定向方法"></a>其他重定向方法</h3><p>HTML 文档的头中包含的 meta refresh 标签可以在其 contnet 属性所指定的秒数之后重定向用户。  </p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://stevesouders.com/newuri&quot;&gt;
</code></pre><p>Javascript 也可以用于执行重定向，将document.location 设置为期望的 URL 即可。<br>注意： 如果你必须进行重定向，最好的技术是使用标准的 3xx HTTP 状态码，这主要是为了确保后退按钮能够正确工作。</p>
<h2 id="重定向是如何损伤性能的"><a href="#重定向是如何损伤性能的" class="headerlink" title="重定向是如何损伤性能的"></a>重定向是如何损伤性能的</h2><p>重定向带来额外的 HTTP 请求，用户等待响应时间变长。</p>
<h2 id="重定向之外的其他选择"><a href="#重定向之外的其他选择" class="headerlink" title="重定向之外的其他选择"></a>重定向之外的其他选择</h2><p>重定向是解决很多问题的简单方式，但最好使用其他不会减慢页面加载速度的解决方案。</p>
<h3 id="缺少结尾的斜线"><a href="#缺少结尾的斜线" class="headerlink" title="缺少结尾的斜线"></a>缺少结尾的斜线</h3><p>有一种重定向最为浪费，发生的也很频繁，但 Web 开发人员通常都没有意识到它。它发生在 URL 的结尾必须出现斜线 （/） 而没有出现时。<br>当缺少结尾的斜线时发送重定向有着很充分的理由——它允许自动索引（autoindexing, 自动转到默认的 index.html上）并且能够获得与当前目录相关的 URL。<br>解决方案： 可通过配置 apache mod_rewrite 模块与 Alias 指令来处理，apache 2.0中，可用 DirectorySlash 指令。<br>注意： 当主机名后缺少结尾斜线时不会发生重定向。因为浏览器在进行 GET 请求时必需指定路径。如果没有路径，它会简单地使用文档根（/），也就是自动添加结尾斜线。<br>参考： <a href="http://www.cnphp6.com/archives/60839" target="_blank" rel="external">配置apache之目录的索引</a><br>总结： 如果你的网站包含目录并使用了自动索引，用户就必须忍受一个到达预期页面的重定向。</p>
<h3 id="连接网站"><a href="#连接网站" class="headerlink" title="连接网站"></a>连接网站</h3><p>将用户从旧 URL 转移到新 URL 最简单的方式就是重定向。重定向是使用定义良好的 API —— URL 来整合两个代码库的一种方式。<br>重定向的常见应用： </p>
<ul>
<li>将旧网站连接到新网站</li>
<li>将一个网站的不同部分连接起来</li>
<li>基于一些条件（浏览器类型、用户账户类型）来引导用户</li>
<li>使用重定向来连接两个网站很简单而且只需要很少的额外代码</li>
</ul>
<p>重定向优点： 降低开发的复杂性，但也损害了用户体验。<br>整合后端还有其他的选择，但比起简单的重定向需要更多的开发工作，不过这样非但不会损害用户体验，还能使之改善： </p>
<ul>
<li>alias、 mod_rewrite 和 DirectorySlash 要求除 URL 之外还要提交到一个接口 (处理器或文件名)，但易于实现</li>
<li>如果两个后端位于同一台服务器上，则它们的代码很可能自己就能够连接。</li>
<li>如果域名变了，可以使用一个 CNAME(一条 DNS 记录，用于创建从一个域名指向另一个域名的别名)让两个主机名指向相同的服务器。如果能够做到这一点，这里提到的技术（alias、 mod_rewrite、 DirectorySlash 和直接连接代码）就是可行的。</li>
</ul>
<h3 id="跟踪内部流量"><a href="#跟踪内部流量" class="headerlink" title="跟踪内部流量"></a>跟踪内部流量</h3><p>跟踪流量去向的两种方式： </p>
<ul>
<li>重定向（只需分析一个站点的 Web 服务器日志）</li>
<li>使用 Referer 日志来跟踪流量去向。每个 HTTP 请求都包含一个 URL，表明从哪个页面发起的请求，也就是引用方（必须分析所有的目标网站）</li>
</ul>
<h3 id="跟踪出站流量"><a href="#跟踪出站流量" class="headerlink" title="跟踪出站流量"></a>跟踪出站流量</h3><p>当你尝试跟踪用户流量时，你会发现连接可能将用户带离你的网站（搜索引擎的搜索结果）。跟踪出站流量的两种方式： </p>
<ul>
<li>重定向（yahoo 通过将每个搜索结果链接包装到一个重定向中来解决跟踪的问题）<br>缺陷： 重定向使得获取目标页面变慢了，对用户体验有负面影响</li>
<li>信标： 一个 HTTP 请求，其 URL 中包含有跟踪信息。跟踪信息可以从信标 Web 服务器的访问日志中提取出来。信标通常是一个 1px X 1px 的透明图片。不过 204 响应更为优秀，因为它更小、从来不会被缓存，而且绝对不会改变浏览器的状态。</li>
<li>上述两种技巧都必须一个额外的 HTTP 请求。另一种方式是使用 XMLHttpRequest 来发送信标</li>
</ul>
<h3 id="美化-URL"><a href="#美化-URL" class="headerlink" title="美化 URL"></a>美化 URL</h3><p>使用重定向的另一种动机是使 URL 更加美观并且易于记忆。<br>关键是要找出一种方式，无需重定向就能拥有如此简洁的 URL。与其让用户忍受额外的 HTTP 请求，最好还是使用alias、 mod_rewrite、 DirectorySlash 和直接链接代码来避免重定向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="./rule11.1.png" alt="alt txt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之十精简Javascript]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8D%81%E7%B2%BE%E7%AE%80Javascript/</url>
      <content type="html"><![CDATA[<p>压缩文件可以减少文件大小，从而减少响应的时间。精简同样可以减少文件大小，但精简和压缩相比所带来的收益相比是有差距的。</p>
<h2 id="精简"><a href="#精简" class="headerlink" title="精简"></a>精简</h2><p>精简是从代码中移除不必要的字符以减小其大小，进而改善加载时间的实践。在代码被精简后，所有的注释以及不必要的空白字符（空格、换行和制表符）都将被移除。</p>
<h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>混淆是可以应用在源代码上的另外一种优化方式。和精简一样，它也会移除注释和空白，同时它还会改写代码。（比如：函数和变量的名字将被转换为更短的字符串，通常这样做是为了增加对代码进行反向工程的难度，同时对提高性能也有帮助，因为这笔精简更能减小代码的大小）。</p>
<h3 id="混淆缺点"><a href="#混淆缺点" class="headerlink" title="混淆缺点"></a>混淆缺点</h3><ul>
<li>缺陷：由于混淆更加复杂，混淆过程本身很有可能引入错误</li>
<li>维护：由于混淆会改变 Javascript 符号，因此需要对任何不能改变的符号（如 API 函数）进行标记，防止混淆其修改它们</li>
<li>调试： 混淆过的代码难以阅读，这使得在产品环境中调试问题更加困难</li>
</ul>
<p>注： 精简和混淆相比，建议使用精简。</p>
<h2 id="节省"><a href="#节省" class="headerlink" title="节省"></a>节省</h2><p>在使用了 gzip 压缩之后，精简和混淆之间的差距将会减小。精简脚本可以降低响应时间，但不会带来混淆的风险。</p>
<h2 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h2><p>内联的 Javascript 块也应该精简。 </p>
<h2 id="压缩和精简"><a href="#压缩和精简" class="headerlink" title="压缩和精简"></a>压缩和精简</h2><p>使用 gzip 来完成压缩，这通常可以使大小减小 70%。gzip 压缩比精简更能减小文件的大小。<br>混淆并压缩的效率和精简并压缩几乎一样，且精简可以避免混淆带来的额外风险。</p>
<h2 id="精简CSS"><a href="#精简CSS" class="headerlink" title="精简CSS"></a>精简CSS</h2><p>精简 CSS 能够带来的节省通常要小于精简 Javascript，因为通常 CSS 中的注释和空白比 Javascript 少。<br>最大的潜在节省来自于优化 CSS —— 合并相同的类、移除不适用的类等。CSS 依赖顺序的本质决定了这是一个复杂的问题。最佳的解决方案还是移除注释和空白，并进行一些直观的优化（比如使用缩写和移除不必要的字符串： ‘0’ 代替 ‘0px’）;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="./rule10.1.png" alt="alt txt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之九减少DNS查找]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%B9%9D%E5%87%8F%E5%B0%91DNS%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>DNS 将主机名映射到 IP 地址上，当你在浏览器中输入 www.yahoo.com 时，连接到浏览器的 DNS 解析器会返回服务器的 IP 地址。<br>DNS 优点： 可以将多个 IP 地址关联到一个主机名，为网站提高冗余度。<br>DNS 缺点： DNS 解析需要花费时间，在 DNS 查找完成之前，浏览器不能从主机名那里下载任何东西。相应时间依赖于 DNS 解析器（通常由你的 ISP 提供）、它所承担的请求压力、你与他之间的距离和你的带宽速度。</p>
<h2 id="DNS-缓存和-TTL"><a href="#DNS-缓存和-TTL" class="headerlink" title="DNS 缓存和 TTL"></a>DNS 缓存和 TTL</h2><p>DNS 查找可以被缓存起来以提高性能。这种缓存发生在你的 ISP 或局域网中的一台特殊的缓存服务器上，同时 DNS 信息会留在用户操作系统的 DNS 缓存中。<br>很多浏览器也拥有自己的缓存，和操作系统的缓存相分离，只要浏览器中保留了 DNS 记录，它就不会麻烦操作系统来请求这个记录。</p>
<h3 id="什么是TTL？"><a href="#什么是TTL？" class="headerlink" title="什么是TTL？"></a>什么是TTL？</h3><p>TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。<br>TTL的作用是限制IP数据包在计算机网络中的存在的时间。TTL的最大值是255，TTL的一个推荐值是64。<br>TTL的主要作用是避免IP包在网络中的无限循环和收发，节省了网络资源，并能使IP包的发送者能收到告警消息。</p>
<h3 id="什么是域名的TTL？"><a href="#什么是域名的TTL？" class="headerlink" title="什么是域名的TTL？"></a>什么是域名的TTL？</h3><p>TTL(Time- To-Live)，简单的说它表示一条域名解析记录在DNS服务器上缓存时间</p>
<h2 id="影响-DNS-缓存的因素"><a href="#影响-DNS-缓存的因素" class="headerlink" title="影响 DNS 缓存的因素"></a>影响 DNS 缓存的因素</h2><p>服务器可以表明记录可以被缓存多久，查找返回的 DNS 记录包含了一个存活时间（Time-to-live, TTL）值。该值告诉客户端可以对该记录缓存多久。<br>影响 DNS 缓存存活多久的因素：</p>
<ul>
<li>尽管操作系统缓存会考虑 TTL 值，但浏览器通常忽略该值，并设置它自己的时间限制。</li>
<li>HTTP 协议中的 Keep-Alive 特性可以同时覆盖 TTL 和浏览器的时间限制（只要浏览器和 Web 服务器愉快的通信着，并保持着 TCP连接打开的状态，就没有理由进行 DNS 查找，避免了重复的 DNS 查找）</li>
<li>浏览器对缓存的 DNS 记录的数量也有限制，而不管缓存记录的时间。如果用户在短时间内访问了很多具有不同域名的网站，较早的 DNS 记录将被丢弃，必须重新查找该域名。</li>
</ul>
<h2 id="TTL-值"><a href="#TTL-值" class="headerlink" title="TTL 值"></a>TTL 值</h2><h3 id="增大TTL值，以节约域名解析时间"><a href="#增大TTL值，以节约域名解析时间" class="headerlink" title="增大TTL值，以节约域名解析时间"></a>增大TTL值，以节约域名解析时间</h3><p>通常情况下域名解析记录是很少更改的。我们可以通过增大域名记录的TTL值让记录在各地DNS服务器中缓存的时间加长，这样在更长的时间段内，我们访问这个网站时，本地ISP的DNS服务器就不需要向域名的NS服务器发出解析请求，而直接从本地缓存中返回域名解析记录。<br>TTL值是以秒为单位的，通常的默认值都是3600，也就是默认缓存1小时。我们可以根据实际需要把TTL值扩大，例如要缓存一天就设置成86400。</p>
<h3 id="减小TTL值，减少更换空间时的不可访问时间"><a href="#减小TTL值，减少更换空间时的不可访问时间" class="headerlink" title="减小TTL值，减少更换空间时的不可访问时间"></a>减小TTL值，减少更换空间时的不可访问时间</h3><p>更换域名空间时会对DNS记录进行修改，因为DNS记录缓存的问题，新的域名记录在有的地方可能生效了，但在有的地方可能等上一两天甚至更久才生效，只就导致有部分用户在一段时间内无法不可访问网站了。<br>为了尽可能的减小这个各地的解析时间差，合理的做法是：<br>1.先查看域名当前的TTL值。<br>2.修改TTL值为可设定的最小值，建议为60秒。<br>3.等待一天，保证各地的DNS服务器缓存都过期并更新了记录。<br>4.设置修改DNS解析到新的记录，这个时候各地的DNS就能以最快的速度更新到新的记录。<br>5.确认各地的DNS已经更新完成后，再TTL值设置成常用的值(如: TTL=86400)。</p>
<p>注意: 客户端收到的 DNS 记录的平均 TTL 值只有最大 TTL 值的一半。</p>
<h2 id="浏览器的视角"><a href="#浏览器的视角" class="headerlink" title="浏览器的视角"></a>浏览器的视角</h2><p>大量独立的变量决定了一个特定的浏览器在请求一个主机名时是否会进行远程 DNS 请求。</p>
<ul>
<li>重新启动 windows 可以清空 DNS Client 服务缓存</li>
<li>重新启动浏览器会清空浏览器缓存，但不会清空 DNS Client 服务缓存</li>
</ul>
<h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>IE 的 DNS 缓存由三个注册表设置控制。</p>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><h2 id="减少-DNS-查找"><a href="#减少-DNS-查找" class="headerlink" title="减少 DNS 查找"></a>减少 DNS 查找</h2><p>当客户端的 DNS 缓存为空（浏览器和操作系统都是）时，DNS 查找的数量与 Web 页面中唯一主机名的数量相等。这包括页面 URL、图片、脚本文件、样式表、Flash对象的主机名。<br>减少唯一主机名的数量就可以减少 DNS 查找的数量。<br>减少唯一主机名的数量的这种方式的<strong>缺点在于</strong>： 会潜在的减少页面中并行下载的数量。避免 DNS 查找降低了相应时间，但减少并行下载可能会增加响应时间。</p>
<p>建议： 将这些组件分别放到至少2个，但不要超过4个主机名下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="./rule9.1.png" alt="alt txt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之八使用外部Javascript和css]]></title>
      <url>https://womenbudon.github.io/2016/11/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%85%AB%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8Javascript%E5%92%8Ccss/</url>
      <content type="html"><![CDATA[<h2 id="内联-VS-外置"><a href="#内联-VS-外置" class="headerlink" title="内联 VS 外置"></a>内联 VS 外置</h2><p>只有一个页面，内联时，减少了 HTTP 请求的数量，导致内联快一些。<br>但是当外部文件 javascript 和 CSS 文件有机会被缓存起来时，外部文件会快些。</p>
<p><strong>关键因素</strong>： 与 HTML 文档请求数量相关的、外部 JAVAscript 和 CSS 组件被缓存的频率。这个因素难以量化，但可以通过下面的手段进行衡量。</p>
<h4 id="页面浏览量"><a href="#页面浏览量" class="headerlink" title="页面浏览量"></a>页面浏览量</h4><p>每个用户产生的页面浏览量越少，内联 Javascript 和 CSS 的论据越强势。另一方面，如果用户产生的页面浏览量很多，则将外部文件放在缓存中，外部文件带来的收益随着页面浏览量的增多而增多。</p>
<h4 id="空缓存-VS-完整缓存"><a href="#空缓存-VS-完整缓存" class="headerlink" title="空缓存 VS 完整缓存"></a>空缓存 VS 完整缓存</h4><p>如果你的网站本质上能够为用户带来高完整缓存率，使用外部文件的收益就更大。如果不大可能产生完整缓存，则内联时更好的选择。</p>
<h4 id="组件重用"><a href="#组件重用" class="headerlink" title="组件重用"></a>组件重用</h4><p>如果你的网站中的每个页面都使用了相同的 Javascript 和 CSS，使用外部文件可以提高这些组件的重用率。</p>
<p>在典型情况下，页面之间 Javascript 和 CSS 的重用既不可能 100% 重叠，也不可能 100% 无关。在这种中间情形中可分为两个极端：</p>
<ul>
<li>为每个页面提供一组分离的外部文件  </li>
<li>创建一个单独的、联合了所有 Javascript 的文件，再创建一个包含了所有 CSS 的文件。</li>
</ul>
<p>最好的方案： 折中，将页面划分为几种页面类型，然后为每种类型创建单独的脚本和样式表。如果可以找到一个平衡点，实现较高的重用度，则使用外部文件更好，反之使用内联。</p>
<h2 id="典型的对比结果"><a href="#典型的对比结果" class="headerlink" title="典型的对比结果"></a>典型的对比结果</h2><p>对内联和使用外部文件进行对比分析时，关键点在于 HTML 文档请求数量相关的，外部 Javascript 和 CSS 组件被缓存的频率。可通过三种基准（页面浏览量、空缓存VS完整缓存和组件重用）来确定最好的选择。</p>
<h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><p>使用内联方式的一个例外就是主页。主页是选择作为浏览器默认也得 URL。从三个基准来看主页： </p>
<ul>
<li>页面浏览量： 主页每月有很高的页面浏览量数量。但通常每个会话只产生一个页面浏览量。</li>
<li>空缓存VS完整缓存： 出于安全的原因，很多用户选择在每次关闭浏览器时，清空缓存（不理解）</li>
<li>组件重用： 很多主页是用户来到网站后访问的唯一一个页面，谈不上重用</li>
</ul>
<h2 id="两全其美"><a href="#两全其美" class="headerlink" title="两全其美"></a>两全其美</h2><p>要想既可以获得内联的优势，同时也能缓存外部文件，可参考下面的两种方法</p>
<h3 id="加载后下载"><a href="#加载后下载" class="headerlink" title="加载后下载"></a>加载后下载</h3><p>对于主页，我们一般希望内联 Javascript 和 CSS，但又希望能为所有后续页面浏览量提供外部文件。可以通过在主页加载完成后动态下载外部组件来实现（通过 onload 事件）。这能够将外部文件放到浏览器的缓存中以便用户接下来访问其他页面。</p>
<h3 id="动态内联"><a href="#动态内联" class="headerlink" title="动态内联"></a>动态内联</h3><p>如果主页服务器知道一个组件是否在浏览器的缓存中，它可以在内联或使用外部文件之间做出最佳的选择。尽管服务器不能查看浏览器缓存中有些什么，但可以用cookies 做指示器。cookie 不存在，内联 js和css,存在则不内联（可能组件已缓存在浏览器中，并使用了外部文件）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="./rule8.1.png" alt="alt txt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之七避免CSS表达式]]></title>
      <url>https://womenbudon.github.io/2016/10/27/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%B8%83%E9%81%BF%E5%85%8DCSS%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>CSS 表达式是动态设置 CSS 属性的一种强大（并且危险）的方式。IE5 和之后的版本支持,其他浏览器不支持。</p>
<h2 id="更新表达式"><a href="#更新表达式" class="headerlink" title="更新表达式"></a>更新表达式</h2><p>表达式的问题在于对其进行求值的频率比人们期望的要高。它们不只在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上拖拽时都要求值。</p>
<h2 id="避开问题"><a href="#避开问题" class="headerlink" title="避开问题"></a>避开问题</h2><p>两种技术避免 CSS 表达式求值频率过高：</p>
<ul>
<li>创建一次性表达式</li>
<li>事件处理器</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在没有深入了解底层影响的情况下使用 CSS 表达式是很危险的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之六将脚本放在底部]]></title>
      <url>https://womenbudon.github.io/2016/10/27/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%85%AD%E5%B0%86%E8%84%9A%E6%9C%AC%E6%94%BE%E5%9C%A8%E5%BA%95%E9%83%A8/</url>
      <content type="html"><![CDATA[<h2 id="脚本带来的问题"><a href="#脚本带来的问题" class="headerlink" title="脚本带来的问题"></a>脚本带来的问题</h2><p>使用脚本时，对于所有位于脚本以下的内容，逐步呈现都被阻塞了。将脚本放在页面越靠下的地方，意味着越多的内容能够逐步地呈现。</p>
<h2 id="并行下载"><a href="#并行下载" class="headerlink" title="并行下载"></a>并行下载</h2><p>HTTP1.1 规范建议浏览器从每个主机名并行地下载两个组件。（可通过浏览器设置并行下载数量）<br>前端工程师与其依赖用户来修改浏览器设置，不如简单地使用 CNAME (DNS 别名) 来将组件分别放到多个主机名中。增加并行下载数量也是有开销的，其优劣取决于你的带宽和CPU速度，过多反而会降低性能。</p>
<blockquote>
<p>Yahoo! 的研究表明，使用两个主机名比使用 1、4 或 10 个主机名能带来更好的性能</p>
</blockquote>
<h2 id="脚本阻塞下载"><a href="#脚本阻塞下载" class="headerlink" title="脚本阻塞下载"></a>脚本阻塞下载</h2><p>在下载脚本时，并行下载实际上是被禁用的——即使使用了不同的主机名，浏览器也不会启动其他的下载。<br>原因如下：</p>
<ul>
<li>脚本可能使用 document.write 来修改页面的内容，因此浏览器会等待，以确保页面能够恰当的布局</li>
<li>为了保证脚本能够按照正确的顺序执行</li>
</ul>
<h2 id="最差情况：将脚本放在顶部"><a href="#最差情况：将脚本放在顶部" class="headerlink" title="最差情况：将脚本放在顶部"></a>最差情况：将脚本放在顶部</h2><p>脚本对 Web 页面的影响就清楚了：</p>
<ul>
<li>脚本会阻塞对其后面内容的呈现（导致白屏）</li>
<li>脚本会阻塞对其后面组件的下载</li>
</ul>
<h2 id="最佳情况：将脚本放在底部"><a href="#最佳情况：将脚本放在底部" class="headerlink" title="最佳情况：将脚本放在底部"></a>最佳情况：将脚本放在底部</h2><p>将脚本放置在底部，不会阻止页面内容的呈现，而且页面中的可视组件可以尽早下载</p>
<h2 id="正确地放置脚本"><a href="#正确地放置脚本" class="headerlink" title="正确地放置脚本"></a>正确地放置脚本</h2><p>正确的放置脚本</p>
<ul>
<li>将脚本移到页面的底部</li>
<li>使用延迟 （Defferred）脚本。 Defferred 属性表明脚本不包含 document.write ,浏览器得到这一线索就可继续进行呈现。（在 Firefox 中，即便是延迟脚本也会阻塞呈现和并行下载），如果一个脚本可以延迟，那么它一定就可以移到页面的底部。</li>
</ul>
<h2 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h2><p><img src="./rule6.1.png" alt="alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之五将样式表放在顶部]]></title>
      <url>https://womenbudon.github.io/2016/10/27/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BA%94%E5%B0%86%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%94%BE%E5%9C%A8%E9%A1%B6%E9%83%A8/</url>
      <content type="html"><![CDATA[<h2 id="逐步呈现"><a href="#逐步呈现" class="headerlink" title="逐步呈现"></a>逐步呈现</h2><p>我们都希望浏览器能够尽快显示内容，为用户提供可视化回馈！</p>
<blockquote>
<p>进度指示器有三个优势——它们让用户知道系统没有崩溃，只是正在为他或她解决问题；它们指出了用户大概还需要等多久，以便用户能够在漫长的等待中做些其他事情；最后它们能给用户提供一些可以看的东西，使得等待不再是那么无聊。最后推荐使用图形进度条而不是仅仅以数字形式显示预期的剩余时间。<br> ——可用性工程师先驱</p>
</blockquote>
<p>在这里，HTML页面就是进度指示器，当浏览器逐步地加载页面时，页头、导航栏、顶端logo等，所有这些都会为等待页面的用户提供视觉反馈。可改善整体用户体验。<br>将样式表放在文档底部会导致在浏览器中阻止内容逐步呈现。为避免当样式变化时重绘页面中的元素，浏览器会阻塞内容逐步呈现。</p>
<h2 id="将-CSS-放在底部"><a href="#将-CSS-放在底部" class="headerlink" title="将 CSS 放在底部"></a>将 CSS 放在底部</h2><p>逐步呈现被禁止了，这是一种不好的用户体验，因为没法向用户确保他的请求正在被正确地处理，用户会因为不知道发生了什么而离开。<br>在IE中样式表放在文档底部会导致白屏问题的情形有以下几种：  </p>
<ul>
<li>在新窗口中打开时</li>
<li>重新加载时</li>
<li>作为主页</li>
</ul>
<h2 id="将-CSS-放在顶部"><a href="#将-CSS-放在顶部" class="headerlink" title="将 CSS 放在顶部"></a>将 CSS 放在顶部</h2><p>为避免白屏，将 CSS 放在顶部，不管页面时如何加载的页面都是逐步呈现的。<br>将样式表包含在文档中有两种方式“</p>
<ul>
<li>使用 LINK 标签</li>
<li>@import 规则</li>
</ul>
<p>@import 规则的缺点：</p>
<ul>
<li>使用 @import 规则会导致组件下载时的无序性</li>
<li>@import 规则有可能会导致白屏现象，即便把 @import 规则放在文档的 HEAD 标签中也是如此</li>
<li>@import 规则必须放在所有其他规则之前</li>
</ul>
<p>最优的方式：使用 LINK 标签将样式表放在文档的 HEAD 中</p>
<h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><p>在浏览器和用户等待位于底部的样式表时，浏览器会延迟显示任何可视化组件，这一现象称之为白屏。<br>将样式表放在文档底部出现白屏现象只出现在IE浏览器中。白屏现象源自于浏览器的行为。</p>
<h2 id="无样式内容闪烁"><a href="#无样式内容闪烁" class="headerlink" title="无样式内容闪烁"></a>无样式内容闪烁</h2><p>无样式内容的闪烁(FOUC)： 文档为样式表使用了一个 CSS 规则，但样式表被（不正确地）放在了底部。当页面逐步加载时，文字首先显示，然后是图片。最后，在样式表正确地下载并解析之后，已经呈现的文字和图片要用新的样式重绘了。 </p>
<h2 id="对于白屏和无样式内容闪烁，我们该怎么办？"><a href="#对于白屏和无样式内容闪烁，我们该怎么办？" class="headerlink" title="对于白屏和无样式内容闪烁，我们该怎么办？"></a>对于白屏和无样式内容闪烁，我们该怎么办？</h2><p>对于两种浏览器在不同的情况下的总结</p>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><p>样式表位于顶部：页面内容逐步呈现<br>样式表位于底部：  </p>
<ul>
<li>与页面呈现内容无关：页面内容逐步</li>
<li>呈现与页面呈现内容有关：出现无样式内容闪烁</li>
</ul>
<h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>样式表位于顶部：逐步加载<br>样式表位于底部：  </p>
<ul>
<li>出现白屏：当重新加载页面、将页面设置为默认首页并打开、在新窗口中打开页面时出现  </li>
<li>出现FOUC：点击链接、键入URL、使用书签 打开页面时</li>
</ul>
<p>解决两种的<strong>最佳方案</strong>： 使用 LINK 标签将样式表放在文档 HEAD 中</p>
<h2 id="附上本节总结"><a href="#附上本节总结" class="headerlink" title="附上本节总结"></a>附上本节总结</h2><p><img src="./rule5.1.png" alt="alt txt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之四压缩]]></title>
      <url>https://womenbudon.github.io/2016/10/26/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%9B%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<p>对 Web 服务器配置进行简单的修改，压缩尽可能多的组件，就能显著改善页面的反应速度</p>
<h2 id="压缩是如何工作的"><a href="#压缩是如何工作的" class="headerlink" title="压缩是如何工作的"></a>压缩是如何工作的</h2><p>Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来表示对压缩的支持；如果 Web 服务器看到这个请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应，Web服务器通过响应中的 Contenet-Encoding 头来通知 Web 客户端。<br>gzip是目前最流行和最有效的压缩方法</p>
<h2 id="压缩什么"><a href="#压缩什么" class="headerlink" title="压缩什么"></a>压缩什么</h2><h3 id="压缩的内容"><a href="#压缩的内容" class="headerlink" title="压缩的内容"></a>压缩的内容</h3><p>包括： XML 和 JSON 在内的任何文本响应！</p>
<h3 id="压缩的成本"><a href="#压缩的成本" class="headerlink" title="压缩的成本"></a>压缩的成本</h3><ul>
<li>服务器端会花费额外的 CPU 周期来完成压缩</li>
<li>客户端要对压缩文件进行解压缩   </li>
</ul>
<p>要检测收益是否大于开销需要考虑的点：  </p>
<ul>
<li>响应的大小</li>
<li>连接的带宽和客户端与服务器之间的 Internet 距离  </li>
</ul>
<p>根据经验： 通常对大于 1KB 或 2KB 的文件进行压缩</p>
<h2 id="压缩带来的收益"><a href="#压缩带来的收益" class="headerlink" title="压缩带来的收益"></a>压缩带来的收益</h2><p>压缩通常能将响应的数据量减少 70%</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置 gzip 时使用的模块取决于 Apache 的版本</p>
<ul>
<li>Apache 1.3 使用 mod_gzip</li>
<li>Apache 2.x 使用 mod_deflate</li>
</ul>
<h2 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h2><h3 id="浏览器直接与服务器通信时"><a href="#浏览器直接与服务器通信时" class="headerlink" title="浏览器直接与服务器通信时"></a>浏览器直接与服务器通信时</h3><p>直接与服务器通信时所进行的配置都能很好的工作</p>
<h3 id="浏览器通过代理来发送请求给服务器时"><a href="#浏览器通过代理来发送请求给服务器时" class="headerlink" title="浏览器通过代理来发送请求给服务器时"></a>浏览器通过代理来发送请求给服务器时</h3><p>第一种情况：假设发送到代理的第一个请求是来自一个不支持 gzip 的浏览器，代理会将请求转发给服务器，服务器给代理未经压缩的响应，代理将此响应缓存并发送给浏览器。如果第二个请求访问的是同一个 URL ，来自一个支持 gzip 压缩的浏览器，则第二个请求获得的还是未经压缩的响应<br>第二种情况： 第一个发送到代理的是支持 gzip 压缩的请求，代理从服务器获得经 gzip 压缩后的响应，响应被代理发送个浏览器并被缓存，第二个请求是不支持 gzip 压缩的浏览器，则它获得的是压缩后的响应，这就问题大了！</p>
<p>解决方案： 在 Web 服务器的响应中添加 Vary 头。 Web 服务器可以告诉代理根据一个或多个请求头来改变缓存的响应,这将使得代理缓存响应的多个版本。压缩的决定是基于 Accept-Encoding 请求头的，因此需要在服务器的 Vary 响应头中包含 Accept-Encoding </p>
<pre><code>Vary: Accept-Encoding
</code></pre><h2 id="边缘情形"><a href="#边缘情形" class="headerlink" title="边缘情形"></a>边缘情形</h2><ul>
<li>发送压缩内容到不支持它的客户端、忘记将压缩内容声明为已经进行了gzip编码等，会导致页面都会被破坏。</li>
<li>在默认情况下，Etag 不能反映出内容是否被压缩，因此代理可能会向浏览器提供错误的内容   解决的办法： 禁用 Etag</li>
</ul>
<blockquote>
<p>错误并不会经常发生，但他们是必须考虑的边缘情形      —经典</p>
</blockquote>
<h3 id="浏览器白名单"><a href="#浏览器白名单" class="headerlink" title="浏览器白名单"></a>浏览器白名单</h3><p>一种安全的方式时只为已经证实过支持压缩的浏览器提供压缩内容。 这就是浏览器白名单，在其他的一些应用中也可以用白名单或黑名单的方式做处理！</p>
<p>如果加上代理的情形则更为复杂，和代理共享浏览器白名单的指令过于复杂，无法使用HTTP头进行编码。最佳做法是将 User-Agent 作为代理的另外一种评判标准添加到 Vary 头中(mod_gzip模块检测到在使用白名单时，会自动添加 User-Agent 到 Vary 头中)</p>
<pre><code>Vary: Accept-Encoding,User-Agent
</code></pre><p>但是 User-Agent 头有上千种不同的值，代理不太可能为其所代理的所有 URL 缓存 Accept-Encoding 和 User-Agent 的全部组合。（甚至将会导致完全禁用为响应包进行的缓存 阔帕）</p>
<h3 id="禁用代理缓存"><a href="#禁用代理缓存" class="headerlink" title="禁用代理缓存"></a>禁用代理缓存</h3><p>使用 Vary: * 或 Cache-Control: Private来禁用代理缓存</p>
<ul>
<li>Vary: *  防止了浏览器使用缓存的组件</li>
<li>Cache-Control: private 为所有浏览器禁用代理缓存（后果： 增加带宽开销）</li>
</ul>
<h3 id="平衡压缩和代理的支持"><a href="#平衡压缩和代理的支持" class="headerlink" title="平衡压缩和代理的支持"></a>平衡压缩和代理的支持</h3><p>平衡压缩和代理的支持需要在加快响应时间、减小带宽开销和边缘情形浏览器缺陷之间进行权衡</p>
<ul>
<li>如果你的网站用户很少，并且他们出于一个小圈子中，边缘情形浏览器就不需要太多关注，可以压缩内容并使用 Vary: Accept-Encoding</li>
<li>如果你更注意带宽开销，可以和前一种情况一样-压缩内容并使用 Vary-Encoding </li>
<li>如果你拥有大量的、多遍的用户群，能够应付较高的带宽开销，并且享有高质量的名声，请压缩内容并使用 Cache-Crontrol: Private。 这禁用了代理缓存单避免了边缘情形的缺陷</li>
</ul>
<h2 id="大作"><a href="#大作" class="headerlink" title="大作"></a>大作</h2><p><img src="./rule4.1.png" alt="alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之三添加Expires头]]></title>
      <url>https://womenbudon.github.io/2016/10/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%B8%89%E6%B7%BB%E5%8A%A0Expires%E5%A4%B4/</url>
      <content type="html"><![CDATA[<p>页面往往包含了大量的组件（脚本、样式表、flash），通过expires头可以使这些组件被缓存,这在后续的页面浏览中避免不必要的HTTP请求。</p>
<h2 id="Expires头"><a href="#Expires头" class="headerlink" title="Expires头"></a>Expires头</h2><p>Web服务器使用Expires头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止。</p>
<pre><code>Expires: Fri, 30 Oct 2017 14:19:41 GMT
</code></pre><h3 id="Expires头的缺陷"><a href="#Expires头的缺陷" class="headerlink" title="Expires头的缺陷"></a>Expires头的缺陷</h3><ul>
<li>Expires头使用一个特定的时间，他要求服务器和客户端的时钟严格同步</li>
<li>过期日期需要经常检查，并且一旦未来这一天到来了，还需要在服务器配置中提供一个新的日期</li>
</ul>
<h2 id="Max-Age-和mod-expires"><a href="#Max-Age-和mod-expires" class="headerlink" title="Max-Age 和mod_expires"></a>Max-Age 和mod_expires</h2><h3 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h3><p>HTTP1.1引入了 Cache-Control 头来克服 Expires 头的限制，Cache-Control 使用 max-age 指令指定组件被缓存多久。</p>
<pre><code>Cache-Control: max-age=315360000
</code></pre><p>对于不支持HTTP1.1的浏览器可同时指定这两个响应头- Expires 和 Cache-Control max-age，若两者同时出现HTTP规范 max-age 指令重写 Expires 头。</p>
<h3 id="mod-expires"><a href="#mod-expires" class="headerlink" title="mod_expires"></a>mod_expires</h3><p>对于不支持HTTP1.1的浏览器，Expries 带来的时钟同步和配置维护问题可以使用 mod_expires Apache 模块，使你在使用Expires头时能够像 max-age 那样相对的方式设置日期。这通过 Expires-Default 指令来完成<br>例如： 在下面的例子中，图片、脚本和样式表的过期时间被设计为自请求开始的10年之后，它同时向响应中发送Expires头和Cache-Control max-age头 </p>
<pre><code>&lt;FilesMatch &quot;\.(gif|jpg|js|css)$&quot;&gt;
ExpiresDefault &quot;access plus 10 years&quot;
&lt;/FilesMatch&gt;
</code></pre><p>跨浏览器改善缓存的<strong>最佳解决方案</strong>就是使用由 ExpiresDefault 设置的 Expires 头</p>
<h2 id="空缓存-VS-完整缓存"><a href="#空缓存-VS-完整缓存" class="headerlink" title="空缓存 VS 完整缓存"></a>空缓存 VS 完整缓存</h2><p>只有在用户已经访问过你的网站之后，长久的 Expires 头才会对页面浏览产生影响，使你的组件可缓存能够改善这些用户的响应时间。<br>空缓存或完整缓存页面浏览的数量取决于Web应用程序的本质。（例如：京东、天猫，商品的图片不可能相同空缓存较好，相比旅游网站或E-mail网站中可能每个用户会话能产生多次页面浏览，完整缓存较好）</p>
<h2 id="不仅仅是图片"><a href="#不仅仅是图片" class="headerlink" title="不仅仅是图片"></a>不仅仅是图片</h2><p>长久的 Expires 头应该包含任何不经常变化的组件，包括脚本、样式表和 Flash 组件，HTML 文档不应该使用长久的 Expires 头，因为它包含动态内容，这些内容在每次用户请求时都将更新。</p>
<h2 id="修订文件名"><a href="#修订文件名" class="headerlink" title="修订文件名"></a>修订文件名</h2><p>为了确保用户能获取组件的最新版本，需要在所有HTML页面中修改组件的文件名。<br>实现方式： 将版本号嵌入在组件的文件名中，嵌入版本号不仅可以改变文件名，还能在调试时更容易找到准确的源代码文件</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Expires 头能够避免额外的 HTTP 请求，可以减少一半的响应时间。<br>相反的情况： 如果一个组件没有长久的 Expires 头，它仍然会存储在浏览器的缓存中。在后续请求中，浏览器会检查缓存并发现组件已经过期。为了提高效率，浏览器会向原始服务器发送一个 GET 请求，如果组件没有改变，原始服务器可以免于发送整个组件，而是发送一个很小的头， 告诉浏览器可以使用其缓存的组件。</p>
<h2 id="大作"><a href="#大作" class="headerlink" title="大作"></a>大作</h2><p><img src="./rule3.1.png" alt="Alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之二使用内容分发网络]]></title>
      <url>https://womenbudon.github.io/2016/10/21/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BA%8C%E4%BD%BF%E7%94%A8%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<p>如果应用程序Web服务器离用户更近，则一个HTTP请求的响应时间将缩短。另一方面，如果组件Web服务器离用户更近，则多个HTTP请求的响应时间将缩短。重新设计应用程序以便将应用程序Web服务器分散开，这样做的难度大。不如将组件Web服务器分散开，这不仅能达到响应时间大幅减少的目的，而且还很容易实现。</p>
<h2 id="内容分布网络"><a href="#内容分布网络" class="headerlink" title="内容分布网络"></a>内容分布网络</h2><p>内容发布网络（CDN）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。<br>CDN用于发布静态内容，如图片、脚本、样式表和Flash</p>
<h3 id="CDN优点"><a href="#CDN优点" class="headerlink" title="CDN优点"></a>CDN优点</h3><ul>
<li>缩短响应时间</li>
<li>备份、扩展存储能力、进行缓存</li>
<li>缓和Web流量峰值</li>
</ul>
<h3 id="CDN缺点"><a href="#CDN缺点" class="headerlink" title="CDN缺点"></a>CDN缺点</h3><ul>
<li>响应时间可能会受到其他网站的流量的影响（CDN服务提供商在其所有客户之间共享其Web服务器组）<br>  解决： 使用两个CDN服务提供商就行了</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化之一减少HTTP请求]]></title>
      <url>https://womenbudon.github.io/2016/10/21/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%B8%80%E5%87%8F%E5%B0%91HTTP%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<p><strong>性能优化黄金法则</strong>： 只有10%~20%的最终用户响应时间花在了下载HTML文档上，其余的80%~90%时间花在了下载页面中的所有组件上（脚本、CSS样式表、图片、Flash）。换我自己的话说，就是改动前端的收益大</p>
<p>关注前端的相对优势:</p>
<ul>
<li>关注前端可以很好的提高性能： 后端响应时间缩短一半，整体响应时间只能减少5%~10%。而如果关注前端性能，同样是将其响应时间减少一半，则整体响应时间减少40%~45%。</li>
<li>改进前端通常只需要较少的时间和资源： 减少后端延迟会带来很大的改动，例如：重新设计应用程序的架构和代码、查找和优化临界代码路径、添加或改动硬件、对数据库进行分布化等。</li>
<li>前端性能调整实践证明可行</li>
</ul>
<h2 id="图片地图"><a href="#图片地图" class="headerlink" title="图片地图"></a>图片地图</h2><p>允许你在一个图片上关联多个URL，目标URL的选择取决于用户点击了图片上的哪个位置。</p>
<h3 id="图片地图两种类型"><a href="#图片地图两种类型" class="headerlink" title="图片地图两种类型"></a>图片地图两种类型</h3><p>服务器端图片地图： 将所有点击提交到同一个目标URL，向其传递用户点击的x、y坐标。Web应用程序将该x、y坐标映射为适当的操作<br>客户端图片地图： 它可以将用户的点击映射到一个操作，而无需向后端应用程序发送请求。映射通过HTML的MAP标签实现。</p>
<h3 id="图片地图的缺点"><a href="#图片地图的缺点" class="headerlink" title="图片地图的缺点"></a>图片地图的缺点</h3><ul>
<li>在定义图片地图的区域坐标时，如果采取手工的方式则很难完成且容易出错</li>
<li>除了矩形之外几乎无法定义其他形状</li>
<li>通过DHTML创建的图片地图在Internet Exploer中无法工作</li>
</ul>
<h3 id="图片地图使用场景"><a href="#图片地图使用场景" class="headerlink" title="图片地图使用场景"></a>图片地图使用场景</h3><p>若导航栏和超链接中使用多个图片，则使用图片地图是加速页面的最简单的方式</p>
<h2 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h2><p>又称为CSS 雪碧图，我用自己的话来总结什么是雪碧图吧，简单来说就是将在页面中需要用到的大量图片合并成一张图片，在一个图标或背景或导航或链接的class样式需要背景图片时，通过CSS样式background-position属性来定位偏移量来得到需要的图片。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>通过合并图片减少了HTTP请求，并且比图片地图更灵活</li>
<li>降低了下载量（合并后的图片比分离的图片小，因为降低了图片吱声的开销（颜色表、格式信息，等等））</li>
</ul>
<h2 id="内联图片"><a href="#内联图片" class="headerlink" title="内联图片"></a>内联图片</h2><p>data: URL 允许将小块数据内联为‘立即数’，数据就在其URL自身之中，其格式如下：<br>data: [&lt; mediatype&gt;][;base64],&lt; data&gt;<br>例如：<br><img src="./rule1.1.png" alt="Alt text"><br>通过使用data: URL模式可以在Web页面中包含图片但无需任何额外的HTTP请求。</p>
<h2 id="内联图片的缺点"><a href="#内联图片的缺点" class="headerlink" title="内联图片的缺点"></a>内联图片的缺点</h2><ul>
<li>data: URL模式的主要缺陷在于不受IE得支持（直到版本7后续版本自己查吧）</li>
<li>可能存在数据大小上的限制</li>
<li>由于data: URL是内联在页面中，在跨越不同页面时不会被缓存<br>  解决： 使用CSS并将内联图片作为背景，将该CSS规则放在外部样式表中，虽然增加了一个额外的HTTP请求，但被缓存后可以得到额外的收获。</li>
</ul>
<h2 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h2><p>模块化的原则是好，便于开发，但是每个文件都会导致一个单独HTTP请求，将这些文件合并到一个文件中，即可减少HTTP请求的数量并缩短最终用户响应时间。在理想的情况下，一个页面应该使用不多于一个的脚本和样式表。</p>
<h3 id="模块化和性能优化的共存"><a href="#模块化和性能优化的共存" class="headerlink" title="模块化和性能优化的共存"></a>模块化和性能优化的共存</h3><p> 对于习惯了编写模块化代码的开发者来说，将所有东西合并到一个单独的文件中像是一种倒退，而将所有的Javascript合并为一个单独的文件在开发环境中很难(一个页面可能需要的脚本的组合很多)。<br><strong>解决的方法:</strong> 遵守编译型语言的模式，保持javascript的模块化，而在生成过程中从一组特定的模块生产一个目标文件。<br><strong>难点:</strong>合并脚本和样式表文件很容易，难得是组合的数量的增长，如果有大量需要不同模块的页面，组合的数量就会非常的大。所以多花一些时间去分析页面，确保组合的数量是可管理的。</p>
<h2 id="最后再附上本人的丑作"><a href="#最后再附上本人的丑作" class="headerlink" title="最后再附上本人的丑作"></a>最后再附上本人的丑作</h2><p><img src="./rule1.2.png" alt="Alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML面试题]]></title>
      <url>https://womenbudon.github.io/2016/10/08/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="doctype-文档类型-的作用是什么？"><a href="#doctype-文档类型-的作用是什么？" class="headerlink" title="doctype(文档类型) 的作用是什么？"></a>doctype(文档类型) 的作用是什么？</h3><p>声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。有以下两个值：</p>
<ul>
<li>怪异模式，浏览器使用自己的怪异模式解析渲染页面。</li>
<li>标准模式，浏览器使用W3C的标准解析渲染页面。<br>这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明,浏览器按照自己的方式解析渲染页面（怪异模式），在不同的浏览器就会显示不同的样式。</li>
</ul>
<p><strong>注意以下几点：</strong>  </p>
<ul>
<li>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；  </li>
<li>&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。  </html></li>
<li>&lt;!DOCTYPE&gt; 不区分大小写  </li>
<li>HTML 5的doctype声明是&lt;!DOCTYPE html&gt;<br>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。</li>
</ul>
<h3 id="浏览器标准模式和怪异模式有什么区别？"><a href="#浏览器标准模式和怪异模式有什么区别？" class="headerlink" title="浏览器标准模式和怪异模式有什么区别？"></a>浏览器标准模式和怪异模式有什么区别？</h3><p><strong>两者的区别：</strong></p>
<ul>
<li>盒模型的解析上： </li>
</ul>
<p>在strict mode中 ：width是内容宽度<br>在quirks mode中 ：width则是元素的实际宽度 ，而内容宽度 = width - (margin-left + margin-right + padding-left + padding-right + border-left-width + border-right-width)</p>
<ul>
<li>图片元素垂直对齐方式</li>
</ul>
<p>在strict mode中 ：vertical-align 属性默认取值为 baseline<br>在quirks mode中 ：vertical align 属性默认为 bottom，因此，在图片底部会有几像素的空间。</p>
<ul>
<li>&lt;table&gt;元素中的字体</li>
</ul>
<p>Quirks Mode 下，对于 table 元素，字体的某些属性将不会从 body 或其他封闭元素继承到 table 中，特别是 font-size 属性。</p>
<ul>
<li>内联元素的尺寸</li>
</ul>
<p>在 Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 Quirks Mode 下，定义这些元素的 width 和 height 属性，能够影响该元素显示的大小尺寸。</p>
<ul>
<li>元素的百分比高度</li>
</ul>
<p>当一个元素使用百分比高度时，在 Standards Mode 下，高度取决于内容的变化，而在 Quirks Mode 下，百分比高度则被正确应用。</p>
<ul>
<li>元素溢出的处理</li>
</ul>
<p>在 Standard Mode 下，overflow 取默认值 visible，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展 box 来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容。</p>
<h3 id="HTML和XHTML的区别是什么？"><a href="#HTML和XHTML的区别是什么？" class="headerlink" title="HTML和XHTML的区别是什么？"></a>HTML和XHTML的区别是什么？</h3><p><strong>主要的不同：</strong>  </p>
<ul>
<li>XHTML可以理解为html+xml，就是用xml的语法来规范html。  </li>
<li>XHTML 元素必须被正确地嵌套。  </li>
<li>XHTML 元素必须被关闭。  </li>
<li>标签名必须用小写字母。  </li>
<li>XHTML 文档必须拥有根元素。</li>
</ul>
<h3 id="如果网页内容需要支持多语言，你会怎么做？"><a href="#如果网页内容需要支持多语言，你会怎么做？" class="headerlink" title="如果网页内容需要支持多语言，你会怎么做？"></a>如果网页内容需要支持多语言，你会怎么做？</h3><p><strong>考虑:</strong></p>
<ul>
<li>应用字符集的选择 utf-8  </li>
<li>语言书写习惯&amp;导航结构  </li>
<li>数据库驱动型网站  </li>
</ul>
<p>具体做法：  </p>
<ul>
<li>静态：就是为每种语言分别准备一套页面文件，要么通过文件后缀名来区分不同语言，要么通过子目录来区分不同语言。   </li>
<li>动态：站点内所有页面文件都是动态页面文件（PHP，ASP等）而不是静态页面文件，在需要输出语言文字的地方统一采用语言变量来表示，这些语言变量可以根据用户选择不同的语言赋予不同的值，从而能够实现在不同的语言环境下输出不同的文字</li>
</ul>
<h3 id="data-属性的作用是什么？"><a href="#data-属性的作用是什么？" class="headerlink" title="data-属性的作用是什么？"></a>data-属性的作用是什么？</h3><p>data-为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取</p>
<h3 id="如果把-HTML5-看作做一个开放平台，那它的构建模块有哪些？"><a href="#如果把-HTML5-看作做一个开放平台，那它的构建模块有哪些？" class="headerlink" title="如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？"></a>如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？</h3><p>开放网络平台（Open Web Platform）是一些开放的（免版权）技术的集合，这些技术激活了互联网。使用开放网络平台时，每个人都有权实现 Web 上的一个组件，而不用向任何人索取许可和证书。<br>构建模块，指的应该是开放网络平台这个技术集合中的技术：<br>HTML<br>DOM<br>CSS<br>SVG<br>MathML<br>Web APIs…<br>EcmaScript / JavaScript<br>HTTP<br>URI<br>Media Accessibility Checklist</p>
<h3 id="请描述-cookies、sessionStorage-和-localStorage-的区别。"><a href="#请描述-cookies、sessionStorage-和-localStorage-的区别。" class="headerlink" title="请描述 cookies、sessionStorage 和 localStorage 的区别。"></a>请描述 cookies、sessionStorage 和 localStorage 的区别。</h3><h4 id="共同点：都是保存在浏览器端，且同源的。"><a href="#共同点：都是保存在浏览器端，且同源的。" class="headerlink" title="共同点：都是保存在浏览器端，且同源的。"></a>共同点：都是保存在浏览器端，且同源的。</h4><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>大小<br>cookie 最多只有 4kb，而 sessionStorage 和 localStorage 大小一般可以有 5M</li>
<li>生命周期<br>cookie 的生命周期由服务器控制，默认是关闭浏览器后删除；sessionStorage 仅在当前的窗口有效，localStorage 除非手动删除否则一直存在。</li>
<li>http 通信<br>浏览器每次向服务器发送请求的时候都要带上该域的 cookie，而 sessionStorage 和 localStorage 仅存在于浏览器端。</li>
<li>作用域<br>cookie 和 localStorage 在同个域名下的多个窗口都有效，sessionStorage 只在一个窗口有效，不能跨窗口共享。</li>
<li>易用性<br>sessionStorage 和 localStorage 属于 HTML5 的 Web Storage 的 API，更加灵活易用。</li>
</ul>
<h4 id="Web-Storage带来的好处："><a href="#Web-Storage带来的好处：" class="headerlink" title="Web Storage带来的好处："></a>Web Storage带来的好处：</h4><ul>
<li>减少网络流量：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。  </li>
<li>快速显示数据：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。      </li>
<li>临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。  </li>
</ul>
<h4 id="服务端存储"><a href="#服务端存储" class="headerlink" title="服务端存储"></a>服务端存储</h4><p>服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。</p>
<ul>
<li>服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。</li>
<li>服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。 实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。 服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中。浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。服务器存储数据安全一些，浏览器只适合存储一般数据。</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="http://harttle.com/2015/08/16/localstorage-sessionstorage-cookie.html" target="_blank" rel="external">H5本地存储</a><br><a href="https://www.pureweber.com/article/how-session-works/" target="_blank" rel="external">session原理</a></p>
<h3 id="请解释-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别"><a href="#请解释-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别" class="headerlink" title="请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别"></a>请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别</h3><p>通过script标签加载js文件时，如果加载过慢，或者出错，有可能会阻塞整个页面的加载，这时就需要js的异步加载，以下两个属性可支持异步加载：<br>defer 和 async 的<strong>共同点</strong>:都是可以并行加载JS文件，不会阻塞页面的加载，<br>defer 和 async 的<strong>不同点</strong>:defer的加载完成之后， JS会等待整个页面全部加载完成了再执行， 而async是加载完成之后，会马上执行JS， 所以假如对JS的执行有严格顺序的话，那么建议用 defer加载。</p>
<h3 id="为什么通常推荐将-CSS-lt-link-gt-放置在-lt-head-gt-lt-head-gt-之间，而将-JS-lt-script-gt-放置在-lt-body-gt-之前？你知道有哪些例外吗？"><a href="#为什么通常推荐将-CSS-lt-link-gt-放置在-lt-head-gt-lt-head-gt-之间，而将-JS-lt-script-gt-放置在-lt-body-gt-之前？你知道有哪些例外吗？" class="headerlink" title="为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？"></a>为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？</h3><h4 id="css放在head中："><a href="#css放在head中：" class="headerlink" title="css放在head中："></a>css放在head中：</h4><ul>
<li>css放在head中， 是因为浏览器解析html文档是自上而下的，如果放底部的话，页面结构出来了，css还没开始渲染，可能会看到只有结构的页面。</li>
<li>CSS 应当写在 head 中，以避免页面元素由于样式确实造成瞬间的白页或者给用户闪烁感。</li>
</ul>
<h4 id="js放在-body之前："><a href="#js放在-body之前：" class="headerlink" title="js放在/body之前："></a>js放在/body之前：</h4><ul>
<li>JS可能会改变DOM树，也可能依赖css样式。如果放在前面，那么DOM和css可能还未加载，这样容易报错。</li>
<li>性能：js放前面，页面会先去加载他，拖慢了时间，使用户在一定时间内看不到网页内容。</li>
</ul>
<p><strong>例外</strong>：js如果需要先加载后运行可以写在头里（当脚本使用 defer 方式加载的时候可以不用约束放置的位置。）；</p>
<h3 id="如果页面使用-‘application-xhtml-xml’-会有什么问题吗？"><a href="#如果页面使用-‘application-xhtml-xml’-会有什么问题吗？" class="headerlink" title="如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？"></a>如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？</h3><p>首先这是个MIME类型，意思就是告诉浏览器，要用xhtml的格式来解析我发给你的页面；<br>xhtml 语法要求严格，必须有head、body 每个dom 必须要闭合。空标签也必须闭合。例如&lt;img /&gt;, &lt;br/&gt;, &lt;input /&gt;等。另外要在属性值上使用双引号。一旦遇到错误，立刻停止解析，并显示错误信息。<br>如果页面使用’application/xhtml+xml’,一些老的浏览器会不兼容。<br>IE6，7，8不支持，IE6，7，8支持text/html。</p>
<h3 id="什么是渐进式渲染-progressive-rendering-？"><a href="#什么是渐进式渲染-progressive-rendering-？" class="headerlink" title="什么是渐进式渲染 (progressive rendering)？"></a>什么是渐进式渲染 (progressive rendering)？</h3><p>渐进式渲染是指浏览器不用等待所有页面资源都渲染好之后再呈现给用户看，而是边下载边渲染，所以用户打开一个网页的时候往往不能第一时间看到所有的内容，但是能够看到一个大概的样子，后续的内容浏览器会慢慢补上形成一个完整的页面。这个有点像 bigpipe。</p>
<h3 id="请解释下什么事语义化的HTML？"><a href="#请解释下什么事语义化的HTML？" class="headerlink" title="请解释下什么事语义化的HTML？"></a>请解释下什么事语义化的HTML？</h3><p>语义化的好处：  </p>
<ul>
<li>去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如&lt;h1&gt;是粗体，字体大小2em，加粗；&lt;strong&gt;是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</li>
<li>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.  </li>
<li>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）.  </li>
<li>搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重.  </li>
<li>你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.  </li>
<li><p>便于团队开发和维护</p>
<p>语义化的HTML就是：标题用h1-h6，文字段落用p，列表用ul li，大致如此</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS面试题]]></title>
      <url>https://womenbudon.github.io/2016/10/08/JS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="请解释事件代理-event-delegation-。"><a href="#请解释事件代理-event-delegation-。" class="headerlink" title="请解释事件代理 (event delegation)。"></a>请解释事件代理 (event delegation)。</h3><p>事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p>
<p><strong>优点：</strong></p>
<ul>
<li>性能得到了优化（需要创建的以及驻留在内存中的事件处理器少了）</li>
<li>动态添加的元素也能绑定事件了</li>
</ul>
<h3 id="请解释-JavaScript-中-this-是如何工作的。"><a href="#请解释-JavaScript-中-this-是如何工作的。" class="headerlink" title="请解释 JavaScript 中 this 是如何工作的。"></a>请解释 JavaScript 中 this 是如何工作的。</h3><p>this 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。</p>
<ul>
<li>函数调用es3和非严格es5为全局对象，严格es5为undefined     </li>
<li>方法调用this指向调用该方法的对象（调用上下文）   </li>
<li>构造函数时，this指向新创建的对象    </li>
<li>call() apply() 调用方法时，this指向调用方法的对象，而不是该方法拥有者对象   </li>
</ul>
<p>参考：<a href="http://blog.jobbole.com/67347/" target="_blank" rel="external">JavaScript中this的工作原理以及注意事项</a> </p>
<h3 id="请解释原型继承-prototypal-inheritance-的原理？"><a href="#请解释原型继承-prototypal-inheritance-的原理？" class="headerlink" title="请解释原型继承 (prototypal inheritance) 的原理？"></a>请解释原型继承 (prototypal inheritance) 的原理？</h3><p>原型继承的基础是原型链查找。</p>
<p>原型链查找基本概念：<br>每一个函数 F 都有一个原型对象（prototype）F.prototype<br>每一个函数都可以通过 new 关键字化身成为一个类构造函数，new F 会产生一个对象 O<br>在调用对象的某个属性或者方法，比如 <a href="http://O.xxx" target="_blank" rel="external">http://O.xxx</a> 的时候，会首先查找对象自身是否有这个方法或者属性，如果没找到就会去对象的构造函数的原型对象中查找（注意有两个定语），也就是查找 O 的构造函数 F 的原型对象 <a href="http://F.prototype.xxx" target="_blank" rel="external">http://F.prototype.xxx</a><br>F.prototype 也是一个对象，查找 <a href="http://F.prototype.xxx" target="_blank" rel="external">http://F.prototype.xxx</a> 的时候会重复第 3 步的过程</p>
<h3 id="你怎么看-AMD-vs-CommonJS？"><a href="#你怎么看-AMD-vs-CommonJS？" class="headerlink" title="你怎么看 AMD vs. CommonJS？"></a>你怎么看 AMD vs. CommonJS？</h3><h3 id="请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式-：function-foo-要做哪些改动使它变成-IIFE"><a href="#请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式-：function-foo-要做哪些改动使它变成-IIFE" class="headerlink" title="请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式)：function foo(){ }();要做哪些改动使它变成 IIFE?"></a>请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式)：function foo(){ }();要做哪些改动使它变成 IIFE?</h3><p>　这里只是声明一个叫foo的function，直接用()执行这样是不成功的，想要变成IIFE就要把声明变成表达式，就可以立即执行了，可以这样(function foo(){})()或者(function foo(){}())，这就是用括号把定义强转成表达式，当然还有其他方法，关键就是声明不可以执行，表达式才可以执行。</p>
<p>参考：<a href="http://gold.xitu.io/entry/5704e12771cfe4005dc85868" target="_blank" rel="external">揭秘IIFE语法</a></p>
<h3 id="描述以下变量的区别：null，undefined-或-undeclared？-该如何检测它们？"><a href="#描述以下变量的区别：null，undefined-或-undeclared？-该如何检测它们？" class="headerlink" title="描述以下变量的区别：null，undefined 或 undeclared？ 该如何检测它们？"></a>描述以下变量的区别：null，undefined 或 undeclared？ 该如何检测它们？</h3><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>未定义，在变量没有赋值的时候的值即为undefined。“缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<h4 id="underclared"><a href="#underclared" class="headerlink" title="underclared"></a>underclared</h4><p>即为被污染的命名，访问没有被声明的变量，会抛出异常，终止执行。尝试访问一个undeclared的变量，浏览器会报错，JS执行会中断。</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>是一个空的对象引用。“没有对象”，即该处不应该有值</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>undefined和null在if语句中，都会被自动转为false，相等运算符甚至直接报告两者相等。typeof undefined会返回undefined ，而typeof null 总返回 object(typeof有六种可能：“number”、“string”、“boolean”、“object”、“function”、“undefined”)</p>
<p>false == undefined;//false<br>false == null;//false<br>null == undefined;//true</p>
<h4 id="该如何检测它们？"><a href="#该如何检测它们？" class="headerlink" title="该如何检测它们？"></a>该如何检测它们？</h4><p>var obj;<br>obj ===undefined;  //检测undfined 方法一<br>typeof obj === ‘undefined’;//检测undefined方法2<br>obj = null;<br>obj === null;//来检测null<br>typeof null;//‘object’  </p>
<h3 id="什么是闭包-closure-，如何使用它，为什么要使用它？"><a href="#什么是闭包-closure-，如何使用它，为什么要使用它？" class="headerlink" title="什么是闭包 (closure)，如何使用它，为什么要使用它？"></a>什么是闭包 (closure)，如何使用它，为什么要使用它？</h3><p><strong>定义：</strong>闭包就是可以读取到其他函数内部变量的函数。<br><strong>闭包的用途：</strong></p>
<ul>
<li>一个是前面提到的可以读取函数内部的变量。(外界无法访问函数的内部的私有方法和变量，只能通过提供的接口访问)</li>
<li>另一个就是让这些变量的值始终保持在内存中。</li>
<li>可以避免污染全局变量，实现私有方法或者变量等</li>
</ul>
<p><strong>注意：</strong>  </p>
<ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<h3 id="请举出一个匿名函数的典型用例？"><a href="#请举出一个匿名函数的典型用例？" class="headerlink" title="请举出一个匿名函数的典型用例？"></a>请举出一个匿名函数的典型用例？</h3><ul>
<li><p>匿名函数可以用作<strong>回调函数</strong>执行，可以防止全局变量污染。</p>
</li>
<li><p>在 JS <strong>框架中常使用</strong>匿名函数来避免全局变量的污染。<br>$.(“input”).each(function(e){this.val(‘OK’)});</p>
</li>
</ul>
<h3 id="你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h3><h3 id="请指出-JavaScript-宿主对象-host-objects-和原生对象-native-objects-的区别？"><a href="#请指出-JavaScript-宿主对象-host-objects-和原生对象-native-objects-的区别？" class="headerlink" title="请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？"></a>请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？</h3><p><strong>原生对象</strong>，独立于宿主环境的 ECMAScript 实现提供的对象。为array obj regexp date function等可以new实例化的对象。</p>
<p><strong>内置对象</strong>为gload Math 等，开发者不必明确实例化内置对象，它已被实例化了。类似于isNaN()、parseInt()和parseFloat()方法等，看起来都是函数，而实际上，它们都是Global对象的方法。具体可以参考 JavaScript 全局对象</p>
<p><strong>宿主对象</strong>。即由 ECMAScript 实现的宿主环境（操作系统和浏览器）提供的对象。所有的BOM和DOM对象都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同（这就是兼容性和特性检测的缘由）。ECMAScript官方未定义的对象都属于宿主对象。</p>
<h3 id="请指出以下代码的区别：function-Person-、var-person-Person-、var-person-new-Person-？"><a href="#请指出以下代码的区别：function-Person-、var-person-Person-、var-person-new-Person-？" class="headerlink" title="请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？"></a>请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？</h3><p>第一个为函数声明，第二个将函数person()返回值赋值给person,第三个通过Person()的构造器创建了一个对象让person变量引用该对象；</p>
<h3 id="call-和-apply-的区别是什么？"><a href="#call-和-apply-的区别是什么？" class="headerlink" title=".call 和 .apply 的区别是什么？"></a>.call 和 .apply 的区别是什么？</h3><p>call和apply都是调用一个对象的一个方法，以另一个对象替换当前对象。它们都属于Function.prototype的一个方法，所以每个function实例都有call和apply属性。这两个方法可以用来代替另一个对象调用一个方法，可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。　　</p>
<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><p>两者传递的参数不同，虽然函数第一个参数都是要传入给当前对象的对象，但是，apply的第二个参数是一个参数数组，将多个参数组合成为一个数组传入；而call第二个参数则是直接的参数列表。</p>
<h3 id="请解释-Function-prototype-bind？"><a href="#请解释-Function-prototype-bind？" class="headerlink" title="请解释 Function.prototype.bind？"></a>请解释 Function.prototype.bind？</h3><p>Function.prototype.bind()其实就是函数绑定。函数的接收者取决于他是如何被调用，可以通过调用.bind()给函数绑定作用域上下文（this的值），即函数的接收者。</p>
<pre><code>var foo = { x: 3} 
var bar = function(){console.log(    this.x);}

bar(); // undefinedvar
boundFunc = bar.bind(foo);//隐式看作是在foo作用域里调用bar方法
boundFunc(); // 3
</code></pre><p> .bind()创建了一个函数，当这个函数在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）也就是我们传入想要的上下文。 简单的用法： 关于 Function.prototype.bind() 内部，这里有个非常简单的例子：</p>
<pre><code>Function.prototype.bind = function (scope) {
    var fn = this;
    return function () {
        return fn.apply(scope);//使用call效果一样
    };
}
</code></pre><h3 id="在什么时候你会使用-document-write-？"><a href="#在什么时候你会使用-document-write-？" class="headerlink" title="在什么时候你会使用 document.write()？"></a>在什么时候你会使用 document.write()？</h3><p>document.write()方法可以用在两个方面：</p>
<ul>
<li>页面载入过程中用实时脚本创建页面内容，该方法需要一个字符串参数，它是写到窗口或框架中的HTML内容。</li>
<li>以及用延时脚本创建本窗口或新窗口的内容。该方法需要一个字符串参数，它是写到窗口或框架中的HTML内容。</li>
</ul>
<p>记住，在载入页面后，浏览器输出流自动关闭。在此之后，任何一个对当前页面进行操作的document.write()方法将打开—个新的输出流，它将清除当前页面内容(包括源文档的任何变量或值)。因此，假如希望用脚本生成的HTML替换当前页面，就必须把HTML内容连接起来赋给一个变量，使用一个document.write()方法完成写操作。不必清除文档并打开一个新数据流，一个document.write()调用就可完成所有的操作。</p>
<p>关于document.write()方法还有一点要说明的是它的相关方法document.close()。脚本向窗口(不管是本窗口或其他窗口)写完内容后，必须关闭输出流。在延时脚本的最后一个document.write()方法后面，必须确保含有document.close()方法，不这样做就不能显示图像和表单。并且，任何后面调用的document.write()方法只会把内容追加到页面后，而不会清除现有内容来写入新值。为了演示document.write()方法，我们提供了同一个应用程序的两个版本。</p>
<p>大多数生成的广告代码依旧使用 document.write()，虽然这种用法会让人很不爽。</p>
<h3 id="请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别？"><a href="#请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别？" class="headerlink" title="请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？"></a>请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？</h3><p>检测浏览器的特殊名称和版本（用户代理检测）即浏览器UA字符串嗅探。浏览器嗅探技术可以快捷的将代码进行分支，以便针对不同的浏览器应用不同的指令；针对特定浏览器的特定版本，超出范围之外都是不可靠的</p>
<h3 id="请尽可能详尽的解释-Ajax-的工作原理？"><a href="#请尽可能详尽的解释-Ajax-的工作原理？" class="headerlink" title="请尽可能详尽的解释 Ajax 的工作原理？"></a>请尽可能详尽的解释 Ajax 的工作原理？</h3><h3 id="使用-Ajax-都有哪些优劣？"><a href="#使用-Ajax-都有哪些优劣？" class="headerlink" title="使用 Ajax 都有哪些优劣？"></a>使用 Ajax 都有哪些优劣？</h3><p>优势：可以刷新局部页面，而不用整体页面都刷新<br>缺点：用户禁用javascript的情况</p>
<h3 id="请解释-JSONP-的工作原理，以及它为什么不是真正的-Ajax。"><a href="#请解释-JSONP-的工作原理，以及它为什么不是真正的-Ajax。" class="headerlink" title="请解释 JSONP 的工作原理，以及它为什么不是真正的 Ajax。"></a>请解释 JSONP 的工作原理，以及它为什么不是真正的 Ajax。</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>JSONP动态创建script标签，回调函数。Ajax是页面无刷新请求数据操作，动态添加一个&amp;ltscript&gt;标签，而script标签的src属性是没有<strong>跨域</strong>的限制的。这样说来，这种跨域方式其实与ajax XmlHttpRequest协议无关了。</p>
<p>当GET请求从被调用页面返回时，可以返回一段JavaScript代码，这段代码会自动调用主页面中的一个callback函数。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>不受同源策略的影响，它的兼容性更好</strong>，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果 　　</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>只支持GET请求而不支持POST</strong>等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p>
<h3 id="请解释变量声明提升-hoisting-。、"><a href="#请解释变量声明提升-hoisting-。、" class="headerlink" title="请解释变量声明提升 (hoisting)。、"></a>请解释变量声明提升 (hoisting)。、</h3><p>在JavaScript代码运行之前其实是有一个编译阶段的。编译之后才是从上到下，一行一行解释执行。变量提升就发生在编译阶段，它把变量和函数的声明提升至作用域的顶端。（编译阶段的工作之一就是将变量与其作用域进行关联）。</p>
<p>变量提升需要<strong>注意两点</strong>：</p>
<ul>
<li>提升的部分只是变量声明，赋值语句和可执行的代码逻辑还保持在原地不动</li>
<li>提升只是将变量声明提升到变量所在的变量范围的顶端，并不是提升到全局范围、</li>
</ul>
<p>函数声明：</p>
<ul>
<li>变量声明和函数声明都会得到变量提升，但函数声明会最先得到提升，然后是变量声明（函数时一等公民）</li>
<li>对于函数声明来说，如果定义了相同的函数变量声明，后定义的声明会覆盖掉先前的声明</li>
</ul>
<p>参考： <a href="https://segmentfault.com/a/1190000003913151" target="_blank" rel="external">Javascript变量提升</a></p>
<h3 id="请描述事件冒泡机制-event-bubbling-。"><a href="#请描述事件冒泡机制-event-bubbling-。" class="headerlink" title="请描述事件冒泡机制 (event bubbling)。"></a>请描述事件冒泡机制 (event bubbling)。</h3><p>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。如果想阻止事件起泡，可以使用e.stopPropagation()（Firefox）或者e.cancelBubble=true（IE）来组织事件的冒泡传播</p>
<p>参考： <a href="https://segmentfault.com/a/1190000000470398" target="_blank" rel="external">事件委托和冒泡机制有关系吗？</a></p>
<h3 id="“attribute”-和-“property”-的区别是什么？"><a href="#“attribute”-和-“property”-的区别是什么？" class="headerlink" title="“attribute” 和 “property” 的区别是什么？"></a>“attribute” 和 “property” 的区别是什么？</h3><p>DOM元素的attribute和property两者是不同的东西。attribute翻译为“特性”，property翻译为“属性”。</p>
<p>attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，attributes是一个类数组的容器，说得准确点就是NameNodeMap，不继承于Array.prototype，不能直接调用Array的方法。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。</p>
<p>property就是一个属性，如果把DOM元素看成是一个普通的Object对象，那么property就是一个以名值对(name=”value”)的形式存放在Object中的属性。要添加和删除property和普通的对象类似。</p>
<p>很多attribute节点还有一个相对应的property属性，比如上面的div元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。</p>
<p>总之，attribute节点都是在HTML代码中可见的，而property只是一个普通的名值对属性</p>
<h3 id="为什么扩展-JavaScript-内置对象不是好的做法？"><a href="#为什么扩展-JavaScript-内置对象不是好的做法？" class="headerlink" title="为什么扩展 JavaScript 内置对象不是好的做法？"></a>为什么扩展 JavaScript 内置对象不是好的做法？</h3><p>因为你不知道哪一天浏览器或javascript本身就会实现这个方法，而且和你扩展的实现有不一致的表现。到时候你的javascript代码可能已经在无数个页面中执行了数年，而浏览器的实现导致所有使用扩展原型的代码都崩溃了。</p>
<p>需要给Array原型添加一个distinct的方法，最好检查是否存在同名的方法，避免自定义方法覆盖原生方法：</p>
<p>Arrray.prototype.distinct = Arrray.prototype.distinct || function(){/…../}</p>
<h3 id="请指出-document-load-和-document-DOMContentLoaded-两个事件的区别。"><a href="#请指出-document-load-和-document-DOMContentLoaded-两个事件的区别。" class="headerlink" title="请指出 document load 和 document DOMContentLoaded 两个事件的区别。"></a>请指出 document load 和 document DOMContentLoaded 两个事件的区别。</h3><p>ready 表示文档的 DOM 已经加载完成（不包含图片、视频等资源）；load 表示整个网页加载完成。可以看出，ready 事件发生在 load 事件之前。</p>
<h3 id="和-有什么不同？"><a href="#和-有什么不同？" class="headerlink" title="== 和 === 有什么不同？"></a>== 和 === 有什么不同？</h3><p>如果两边的操作数具有一致的类型且拥有相同的值时，=== 返回 true，!== 返回 false。</p>
<h3 id="请解释-JavaScript-的同源策略-same-origin-policy-。"><a href="#请解释-JavaScript-的同源策略-same-origin-policy-。" class="headerlink" title="请解释 JavaScript 的同源策略 (same-origin policy)。"></a>请解释 JavaScript 的同源策略 (same-origin policy)。</h3><p>同源策略限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。</p>
<p>同源策略出于安全，不允许源 A 的脚本读取（read）源 B 的资源的内容，但却允许执行（execute）源 B 的资源。这个概念也有些拗口。简单说，有一个页面调用了 Google CDN 提供的 jQuery，以及其它 CDN 上的 Bootstrap JS、CSS 代码，虽然它们与我的博客不同源，但我可以用它们来操作这个页面，并应用样式，这是执行的概念。</p>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">浏览器的同源策略</a></p>
<h3 id="如何实现下列代码：-1-2-3-4-5-duplicator-1-2-3-4-5-1-2-3-4-5"><a href="#如何实现下列代码：-1-2-3-4-5-duplicator-1-2-3-4-5-1-2-3-4-5" class="headerlink" title="如何实现下列代码：[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]"></a>如何实现下列代码：[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]</h3><p>将此方法添加至 Array.prototype 实现，代码如下：  </p>
<pre><code>Array.prototype.duplicator = function(){
　　var l = this.length,i;
　　for(i=0;i&lt;l;i++){
　　　this.push(this[i])　
   }
}
</code></pre><h3 id="什么是三元表达式-Ternary-expression-？“三元-Ternary-”-表示什么意思？"><a href="#什么是三元表达式-Ternary-expression-？“三元-Ternary-”-表示什么意思？" class="headerlink" title="什么是三元表达式 (Ternary expression)？“三元 (Ternary)” 表示什么意思？"></a>什么是三元表达式 (Ternary expression)？“三元 (Ternary)” 表示什么意思？</h3><p>一个运算符如果有一个操作数，为一元运算符，两个为二元，三个为三元运算符，三元表达式则为一个三元运算表达式！</p>
<h3 id="什么是-“use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是-“use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是 “use strict”; ? 使用它的好处和坏处分别是什么？"></a>什么是 “use strict”; ? 使用它的好处和坏处分别是什么？</h3><p>ECMAScript5中引入的严格模式,通过让JavaScript运行环境对一些开发过程中最常见和不易发现的错误做出和当前不同的处理,来让开发者拥有一个”更好”的JavaScript语言。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全； </li>
<li>提高编译器效率，增加运行速度； </li>
<li>为未来新版本的Javascript做好铺垫。 </li>
</ul>
<h4 id="好处具体体现"><a href="#好处具体体现" class="headerlink" title="好处具体体现"></a>好处具体体现</h4><ul>
<li>去除WITH关键词</li>
<li>防止意外为全局变量赋值</li>
<li>函数中的THIS不再默认指向全局</li>
<li>防止重名</li>
<li>安全的 EVAL()</li>
<li>对只读属性修改时抛出异常<h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4></li>
</ul>
<p>同样的代码，在“严格模式”中，可能会有不一样的运行结果；一些在“正常模式”下可以运行的语句，在“严格模式”下将不能运行</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>启用JavaScript严格模式,它能帮你发现代码中未曾注意到的错误。不要在全局环境中启用,但你能尽量多的使用IIFE(立即执行函数表达式)来把严格模式作用到多个函数范围内。一开始,你会遇到之前未曾碰到过的错误提示,这是正常的。当启用严格模式后,请确保在支持的浏览器中做了测试,以发现新的潜在问题。一定不要仅仅在代码中添加一行”use strict”就假定余下的代码能正常工作。  </p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p> <a href="http://flandycheng.blog.51cto.com/855176/982719" target="_blank" rel="external">JavaScript严谨模式(Strict Mode)提升开发效率和质量</a></p>
<h3 id="请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”。"><a href="#请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”。" class="headerlink" title="请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。"></a>请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。</h3><pre><code>for (var i = 1; i &lt;= 30; i++) {

    if (i % 3 === 0) {
        if (i % 5 === 0) {
            alert(&apos;fizzbuzz&apos; + i);
            continue;
        }
        alert(&apos;fizz&apos; + i);
        continue;
    } else if (i % 5 === 0) {
        if (i % 3 === 0) {
            alert(&apos;fizzbuzz&apos; + i);
            continue;
        }
        alert(&apos;buzz&apos; + i);
        continue;
    }
}
</code></pre><h3 id="为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？"><a href="#为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？" class="headerlink" title="为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？"></a>为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？</h3><p>它的意思是: 尽量少在全局作用域定义变量。</p>
<p>目的:</p>
<p>减少名称冲突 利于模块化</p>
<h3 id="为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"><a href="#为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？" class="headerlink" title="为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"></a>为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？</h3><p>要等到等页面完全加载后(所有图像、javascript文件、CSS等外部文件)。替代：把script标签放到最后面。</p>
<h3 id="请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly-。"><a href="#请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly-。" class="headerlink" title="请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。"></a>请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。</h3><p>单页应用是一种特殊的web应用，它将所有的活动局限于一个web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>用户体验：对于内容的改动不需要加载整个页面</li>
<li>高效：服务器压力很小，消耗更少的带宽，能够与面向服务的架构更好地结合。</li>
<li>经典MVC开发模式，前后端各负其责。</li>
<li>一套Server API，多端使用（web、移动APP等）</li>
<li>重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>不利于SEO：解决方案也有一些：H5pushState,通过浏览器历史记录让搜索引擎抓取；url中#！</p>
<pre><code>复杂的单页架构页面，对Google来说抓取比较困难，于是给开发者制定一个规范：  
    1）、网站提交sitemap给Google；  
    2）、Google发现URL里有#!符号，例如example.com/#!/detail/1，于是Google开始抓取example.com/?_escaped_fragment_=/detail/1；_escaped_fragment_这个参数是Google指定的命名，如果开发者希望把网站内容提交给Google，就必须通过这个参数生成静态页面。
</code></pre></li>
<li><p>首屏渲染速度慢</p>
</li>
</ul>
<h3 id="使用-Promises-而非回调-callbacks-优缺点是什么？"><a href="#使用-Promises-而非回调-callbacks-优缺点是什么？" class="headerlink" title="使用 Promises 而非回调 (callbacks) 优缺点是什么？"></a>使用 Promises 而非回调 (callbacks) 优缺点是什么？</h3><p>优点：易读性改善</p>
<h3 id="使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？"><a href="#使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？" class="headerlink" title="使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？"></a>使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？</h3><p>以Typescript为例子：<br>typescript是javascript的强类型版本，在编译期去掉类型和特有语法，生成纯粹的javascript代码。TypeScript 是 JavaScript 的超集，这意味着他支持所有的 JavaScript 语法。并在此之上对 JavaScript 添加了一些扩展，如 class / interface / module 等。这样会大大提升代码的可阅读性。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>静态类型检查 </li>
<li>IDE 智能提示 （编译阶段即可发现类型不匹配的错误）</li>
<li>代码重构 </li>
<li>可读性</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>不指定类型就写不了程序，类型只是辅助信息，并不是程序的本之后</li>
<li>灵活性问题</li>
</ul>
<h3 id="你使用哪些工具和技术来调试-JavaScript-代码？"><a href="#你使用哪些工具和技术来调试-JavaScript-代码？" class="headerlink" title="你使用哪些工具和技术来调试 JavaScript 代码？"></a>你使用哪些工具和技术来调试 JavaScript 代码？</h3><ul>
<li>alert</li>
<li>console.log</li>
<li>断点调试（这三种调试方式都是打断点）<br>  js断点调试<br>  source断点调试<br>  Debugger断点（具体的说就是通过在代码中添加”debugger;”语句，当代码执行到该语句的时候就会自动断点。）  </li>
<li>DOM断点调试<br>  当节点内部子节点变化时断点<br>  当节点属性发生变化时断点<br>  当节点被移除时断点  </li>
</ul>
<p>参考： <a href="http://www.css88.com/archives/6137" target="_blank" rel="external">前端开发中的JS调试技巧</a></p>
<h3 id="请解释可变-mutable-和不变-immutable-对象的区别？"><a href="#请解释可变-mutable-和不变-immutable-对象的区别？" class="headerlink" title="请解释可变 (mutable) 和不变 (immutable) 对象的区别？"></a>请解释可变 (mutable) 和不变 (immutable) 对象的区别？</h3><p>javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此—-改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。</p>
<h4 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h4><ul>
<li>可变性：对象和原始值不同，首先，它们是可变的–它们的值是可修改的</li>
<li>值的比较：对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素相等的两个数组也不相等。</li>
</ul>
<h3 id="不变性-immutability-有哪些优缺点？"><a href="#不变性-immutability-有哪些优缺点？" class="headerlink" title="不变性 (immutability) 有哪些优缺点？"></a>不变性 (immutability) 有哪些优缺点？</h3><p><strong>优点：</strong></p>
<ul>
<li>因为不能修改一个不变对象的状态，所以可以避免由此引起的不必要的程序错误；一个不变的对象要比一个可变的对象更加容易维护。</li>
<li>因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样可以省掉处理同步化的开销。一个不变对象可以自由地被不同的客户端共享。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>一旦需要修改一个不变对象的状态，就只好创建一个新的同类对象。在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建出来，这是一种资源上的浪费。</li>
</ul>
<h3 id="如何用你自己的代码来实现不变性-immutability-？"><a href="#如何用你自己的代码来实现不变性-immutability-？" class="headerlink" title="如何用你自己的代码来实现不变性 (immutability)？"></a>如何用你自己的代码来实现不变性 (immutability)？</h3><p>可以使用<strong>const 修饰变量不可变</strong></p>
<p>参考： <a href="http://stylechen.com/immutable-in-javascript.html" target="_blank" rel="external">Immutable 在 JavaScript 中的应用</a></p>
<h3 id="你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？"><a href="#你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？" class="headerlink" title="你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？"></a>你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？</h3><h3 id="请解释同步-synchronous-和异步-asynchronous-函数的区别。"><a href="#请解释同步-synchronous-和异步-asynchronous-函数的区别。" class="headerlink" title="请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。"></a>请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。</h3><h4 id="同步式"><a href="#同步式" class="headerlink" title="同步式"></a>同步式</h4><p> 当计算机调度线程进行I/O操作命令后，由于文件的读写或者网络通信需要较长的操作时间，操作系统为了充分利用cpu，此时会暂停到当前的I/O线程对CPU的控制（故又称同步式为阻塞式I/O），把cup资源然给其他的线程资源，当I/O线程完成了操作时，此时操作系统会恢复此时的I/O线程，从而当前I/O线程重新获得了cup的的控制权，继续完成其他操作。   </p>
<h4 id="异步式"><a href="#异步式" class="headerlink" title="异步式"></a>异步式</h4><p>异步式IO又称非阻塞式I/O，异步式与同步式不同的是，当线程进行IO操作时，操作系统并不是暂停当前的线程操作，而是执行完I/O指令后，操作系统继续让当前线程执行下一条指令，当I/O操作完成后，会通过事件（event)通知I/O线程，而线程在接收到通知后，会处理响应事件。</p>
<h3 id="什么是事件循环-event-loop-？"><a href="#什么是事件循环-event-loop-？" class="headerlink" title="什么是事件循环 (event loop)？"></a>什么是事件循环 (event loop)？</h3><p>主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<h3 id="请问调用栈-call-stack-和任务队列-task-queue-的区别是什么？"><a href="#请问调用栈-call-stack-和任务队列-task-queue-的区别是什么？" class="headerlink" title="请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？"></a>请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？</h3><p>所谓“回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当异步任务从“任务队列”回到执行栈，回调函数就会执行。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先返回主线程。主线程的读取过程基本上是自动的，只要执行栈一清空，“任务队列”上第一位的事件就自动返回主线程。但是，由于存在后文提到的“定时器”功能，主线程要检查一下执行时间，某些事件必须要在规定的时间返回主线程。</p>
<h3 id="解释-function-foo-与-var-foo-function-用法的区别？"><a href="#解释-function-foo-与-var-foo-function-用法的区别？" class="headerlink" title="解释 function foo() {} 与 var foo = function() {} 用法的区别？"></a>解释 function foo() {} 与 var foo = function() {} 用法的区别？</h3><p>第一个未函数声明，第二个为函数定义表达式（函数定义表达式foo，变量声明提前单赋值并未提前）</p>
<h2 id="JS面试题"><a href="#JS面试题" class="headerlink" title="JS面试题"></a>JS面试题</h2><p>准备的清粥小菜：</p>
<ul>
<li><a href="https://my.oschina.net/Jsiwa/blog/272761" target="_blank" rel="external">面试题一</a></li>
<li><a href="http://www.cnblogs.com/coco1s/p/4029708.html" target="_blank" rel="external">面试题二</a></li>
<li><a href="https://github.com/infp/Front-end-Interview/blob/master/source/javascript.md" target="_blank" rel="external">面试题三</a></li>
<li><a href="http://www.cnblogs.com/laiqun/p/5479393.html" target="_blank" rel="external">js答案（本套题）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS面试题]]></title>
      <url>https://womenbudon.github.io/2016/09/28/CSS%E9%9D%A2%E8%AF%95%E9%A2%98-1/</url>
      <content type="html"><![CDATA[<h3 id="CSS-中类-classes-和-ID-的区别。"><a href="#CSS-中类-classes-和-ID-的区别。" class="headerlink" title="CSS 中类 (classes) 和 ID 的区别。"></a>CSS 中类 (classes) 和 ID 的区别。</h3><ul>
<li>书写上的差别：class名用“.”号开头来定义，id名用“#”号开头来定义；   </li>
<li>优先级不同（权重不同）  </li>
<li>调用上的区别：在同一个html网页页面中class是可以被多次调用的（在不同的地方）。而id名作为标签的身份则是唯一的，id在页面中只能出现一次。在js脚本中经常会用到id来修改一个标签的属性         </li>
<li>id作为元素的标签，用于区分不同结构和内容，而class作为一个样式，它可以应用到任何结构和内容上。   </li>
<li>在布局思路上，一般坚持这样的原则：id是先确定页面的结构和内容，然后再为它定义样式：而class相反，它先定义好一类样式，然后再页面中根据需要把类样式应用到不同的元素和内容上面。   </li>
<li>在实际应用时，class更多的被应用到文字版块以及页面修饰等方面，而id更多地被用来实现宏伟布局和设计包含块，或包含框的样式。</li>
</ul>
<p><strong>一般原则：</strong> 类应该应用于概念上相似的元素，这些元素可以出现在同一页面上的多个位置，而ID 应该应用于不同的唯一的元素</p>
<h3 id="请问-“resetting”-和-“normalizing”-CSS-之间的区别？你会如何选择，为什么？"><a href="#请问-“resetting”-和-“normalizing”-CSS-之间的区别？你会如何选择，为什么？" class="headerlink" title="请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？"></a>请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？</h3><p>Normalize 相对「平和」，注重通用的方案，重置掉该重置的样式，保留有用的 user agent 样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。<br>Reset 相对「暴力」，不管你有没有用，统统重置成一样的效果，且影响的范围很大，讲求跨浏览器的一致性。【摘自知乎】   </p>
<p><a href="http://jerryzou.com/posts/aboutNormalizeCss/" target="_blank" rel="external">http://jerryzou.com/posts/aboutNormalizeCss/</a><br>Normalize.css是一种CSS reset的替代方案。它们的区别有： </p>
<ul>
<li>Normalize.css 保护了有价值的默认值，Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并尽可能与现代标准相符合。   </li>
<li>Normalize.css 修复了浏览器的bug，它修复了常见的桌面端和移动端浏览器的bug。这往往超出了Reset所能做到的范畴。关于这一点，Normalize.css修复的问题包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。   </li>
<li>Normalize.css 不会让你的调试工具变的杂乱 </li>
<li>Normalize.css 是模块化的 </li>
<li>Normalize.css 拥有详细的文档<br>选择Normalize.css ，主要是reset.css为几乎所有的元素施加默认样式，所以需要对所有公共的排版元素重新设置样式，这是一件很麻烦的工作。</li>
</ul>
<h3 id="请解释浮动-Floats-及其工作原理"><a href="#请解释浮动-Floats-及其工作原理" class="headerlink" title="请解释浮动 (Floats) 及其工作原理"></a>请解释浮动 (Floats) 及其工作原理</h3><p>浮动出现的最开始出现的意义是用来让<strong>文字环绕</strong>图片而已。<br>float可以自动包裹元素。<br>float会导致父容器高度塌陷。float为什么会导致高度塌陷：元素含有浮动属性 –&gt; 破坏inline box –&gt; 破坏line box高度 –&gt; 没有高度 –&gt; 塌陷。什么时候会塌陷：当标签里面的元素只要样子没有实际高度时会塌陷。<br>浮动会脱离文档流。产生自己的块级格式化上下文。</p>
<h3 id="描述z-index和叠加上下文是如何形成的。"><a href="#描述z-index和叠加上下文是如何形成的。" class="headerlink" title="描述z-index和叠加上下文是如何形成的。"></a>描述z-index和叠加上下文是如何形成的。</h3><p>首先来看在CSS中叠加上下文形成的原因：</p>
<ul>
<li>负边距<br>margin为负值时元素会依参考线向外偏移。margin-left/margin-top的参考线为左边的元素/上面的元素（如无兄弟元素则为父元素的左内侧/上内侧）,margin-right和margin-bottom的参考线为元素本身的border右侧/border下侧。一般可以利用负边距来就行布局，但没有计算好的话就可能造成元素重叠。堆叠顺序由元素在文档中的先后位置决定，后出现的会在上面。   </li>
<li>position的relative/absolute/fixed定位<br>当为元素设置position值为relative/absolute/fixed后，元素发生的偏移可能产生重叠，且z-index属性被激活。z-index值可以控制定位元素在垂直于显示屏方向（Z 轴）上的堆叠顺序（stack order），值大的元素发生重叠时会在值小的元素上面。 </li>
</ul>
<p><strong>z-index属性 ：</strong>z-index只能在position属性值为relative或absolute或fixed的元素上有效。<br><strong>基本原理</strong>：z-index值可以控制定位元素在垂直于显示屏方向（Z 轴）上的堆叠顺序（stack order），值大的元素发生重叠时会在值小的元素上面。<br><strong>使用相对性：</strong>z-index值只决定同一父元素中的同级子元素的堆叠顺序。父元素的z-index值（如果有）为子元素定义了堆叠顺序（css版堆叠“拼爹”）。向上追溯找不到含有z-index值的父元素的情况下，则可以视为自由的z-index元素，它可以与父元素的同级兄弟定位元素或其他自由的定位元素来比较z-index的值，决定其堆叠顺序。同级元素的z-index值如果相同，则堆叠顺序由元素在文档中的先后位置决定，后出现的会在上面。所以如果当你发现一个z-index值较大的元素被值较小的元素遮挡了，请先检查它们之间的dom结点关系，多半是因为其父结点含有激活并设置了z-index值的position定位元素</p>
<h3 id="请描述-BFC-Block-Formatting-Context-及其如何工作？"><a href="#请描述-BFC-Block-Formatting-Context-及其如何工作？" class="headerlink" title="请描述 BFC(Block Formatting Context) 及其如何工作？"></a>请描述 BFC(Block Formatting Context) 及其如何工作？</h3><p>BFC:块级格式上下文。定义：<br>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。<br>在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。两个相邻的块级盒子的垂直外边距会发生叠加。<br>在块级格式化上下文中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。</p>
<p>BFC详解： <a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a></p>
<h3 id="block，inline和inline-block的概念以及区别"><a href="#block，inline和inline-block的概念以及区别" class="headerlink" title="block，inline和inline-block的概念以及区别"></a>block，inline和inline-block的概念以及区别</h3><h4 id="display-block"><a href="#display-block" class="headerlink" title="display:block"></a>display:block</h4><ul>
<li>block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。   </li>
<li>block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。   </li>
<li>block元素可以设置margin和padding属性。   </li>
</ul>
<h4 id="display-inline"><a href="#display-inline" class="headerlink" title="display:inline"></a>display:inline</h4><ul>
<li>inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 </li>
<li>inline元素设置width,height属性无效。 </li>
<li>inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top,<br>padding-bottom, margin-top, margin-bottom不会产生边距效果。 </li>
</ul>
<h4 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display:inline-block"></a>display:inline-block</h4><p>就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。</p>
<p>备注：属性为inline-block元素之间的空格或者换行在浏览器上会是一个空白的间隙。且IE6和7是不支持这个属性的，需要通过<em>display:inline;</em>zoom:1做hack处理。</p>
<h3 id="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"><a href="#列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。" class="headerlink" title="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"></a>列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。</h3><ul>
<li><p>添加新的元素、应用 clear：both；</p>
<pre><code>&lt;div class=&quot;outer&quot;&gt; 
&lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; 
&lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; 
&lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; 
&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 
&lt;/div&gt; 
.clear{clear:both; height: 0; line-height: 0; font-size: 0} 
</code></pre><p>  优点：简单，代码少，浏览器支持好，不容易出现怪问题<br>  缺点是要增加很多无效布局，但这是清除浮动用的比较多的一种方法。</p>
</li>
<li><p>父级div定义overflow：auto或者hidden </p>
<pre><code>&lt;div class=&quot;outer over-flow&quot;&gt; //这里添加了一个class 
&lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; 
&lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; 
&lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; 
&lt;/div&gt; 
.over-flow{ 
    overflow: auto; zoom: 1; //zoom: 1; 是在处理兼容性问题 
} 
</code></pre><p>  原理：必须定义width或zoom:1，同时不能定义height，使用overflow属性来清除浮动有一点需要注意，overflow属性共有三个属性值：hidden,auto,visible。我们可以使用hiddent和auto值来清除浮动，但切记不能使用visible值，如果使用这个值将无法达到清除浮动效果。<br>  优点：简单，代码少，浏览器支持好<br>  缺点：使用auto时内部宽高超过父级div时，会出现滚动条，使用hidden时会被隐藏</p>
</li>
</ul>
<ul>
<li><p>after 方法 </p>
<pre><code>&lt;div class=&quot;outer&quot;&gt; 
&lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; 
&lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; 
&lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt; 
&lt;/div&gt; 
.outer {zoom:1;} /==for IE6/7 Maxthon2==/ 
.outer :after {clear:both;content:’.’;display:block;width: 0;height: 0;visibility:hidden;} 
</code></pre><p>  其中clear:both;指清除所有浮动；content: ‘.’; display:block;对于FF/chrome/opera/IE8不能缺少，其中content（）可以取值也可以为空。visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来，这样才能实现清除浮动。<br>  所以总的来说，<strong>推荐使用伪类的办法</strong>。</p>
</li>
</ul>
<h3 id="请解释-CSS-sprites，以及你要如何在页面或网站中实现它。"><a href="#请解释-CSS-sprites，以及你要如何在页面或网站中实现它。" class="headerlink" title="请解释 CSS sprites，以及你要如何在页面或网站中实现它。"></a>请解释 CSS sprites，以及你要如何在页面或网站中实现它。</h3><p>CSS Sprites就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。<br><strong>优点</strong>：当页面加载时，不是加载每个单独图片，而是一次加载整个组合图片。这是一个了不起的改进，它大大减少了HTTP请求的次数，减轻服务器压力，同时缩短了悬停加载图片所需要的时间延迟，使效果更流畅，不会停顿。<br><strong>缺点</strong>：做图像拼合的时候很麻烦。</p>
<h3 id="你最喜欢的图片替换方法是什么，你如何选择使用。"><a href="#你最喜欢的图片替换方法是什么，你如何选择使用。" class="headerlink" title="你最喜欢的图片替换方法是什么，你如何选择使用。"></a>你最喜欢的图片替换方法是什么，你如何选择使用。</h3><h3 id="你会如何解决特定浏览器的样式问题？"><a href="#你会如何解决特定浏览器的样式问题？" class="headerlink" title="你会如何解决特定浏览器的样式问题？"></a>你会如何解决特定浏览器的样式问题？</h3><p>浏览器的兼容性：</p>
<p>解决方案：</p>
<ul>
<li>主张向前兼容，不考虑向后兼容，</li>
<li>根据产品的用户群中各大浏览器，来考虑需要兼容的浏览器</li>
<li>把浏览器分两类，一类历史遗留浏览器，一类是现代浏览器，然后根据这个分类开发两个版本的网站，然后自己定义哪些浏览器是历史遗留版本，历史遗留版本浏览器，是用历史遗留界面，通过通告栏告知用户使用现代浏览器，功能更全面，提供好的用户体验</li>
<li>直接在用户的浏览器不能兼容的时候，提示用户至少什么版本的IE和火狐谷歌浏览器才能支持（以上方案都失效）</li>
<li>项目开始前就得需要确认兼容支持的最低按本是什么，设计一个对应的兼容方案</li>
</ul>
<h3 id="如何为有功能限制的浏览器提供网页？"><a href="#如何为有功能限制的浏览器提供网页？" class="headerlink" title="如何为有功能限制的浏览器提供网页？"></a>如何为有功能限制的浏览器提供网页？</h3><h3 id="有哪些的隐藏内容的方法-如果同时还要保证屏幕阅读器可用呢-？"><a href="#有哪些的隐藏内容的方法-如果同时还要保证屏幕阅读器可用呢-？" class="headerlink" title="有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？"></a>有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？</h3><h4 id="display-none-文本图片的隐藏"><a href="#display-none-文本图片的隐藏" class="headerlink" title="display:none 文本图片的隐藏"></a>display:none 文本图片的隐藏</h4><ul>
<li><p>缺陷：搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略</p>
</li>
<li><p>屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字，同时不利于搜索引擎。  </p>
<h4 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility: hidden"></a>visibility: hidden</h4><pre><code>缺陷：隐藏的内容会占据他所应该占据物理空间
</code></pre></li>
</ul>
<h4 id="overflow-hidden-隐藏内容或图片"><a href="#overflow-hidden-隐藏内容或图片" class="headerlink" title="overflow: hidden 隐藏内容或图片"></a>overflow: hidden 隐藏内容或图片</h4><h3 id="你用过栅格系统-grid-system-吗？如果使用过，你最喜欢哪种？"><a href="#你用过栅格系统-grid-system-吗？如果使用过，你最喜欢哪种？" class="headerlink" title="你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？"></a>你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？</h3><p>Bootstrap中的流式布局；Bootstrap提供了两种布局方式，<strong>固定式布局</strong>和<strong>流式布局</strong>（用em表示的叫做弹性布局，用百分比表示的叫做流体布局）方式，Bootstrap的布局实际上是在栅格外加个容器 (Container)<br>因此两种布局方式的唯一区别是：<br><strong>固定布局</strong>加的是固定宽度(width)的容器，<br><strong>流式布局</strong>加的是自适应(或叫可变)宽度的容器。</p>
<h3 id="你用过媒体查询，或针对移动端的布局-CSS-吗？"><a href="#你用过媒体查询，或针对移动端的布局-CSS-吗？" class="headerlink" title="你用过媒体查询，或针对移动端的布局/CSS 吗？"></a>你用过媒体查询，或针对移动端的布局/CSS 吗？</h3><p>媒体查询规则是开发者能够在相同的样式中，针对不同的媒介来使用不同的样式规则。在CSS2的时候有media Type的规则，通过不同的媒介来切换不同的CSS样式。通过媒体查询的技术可以实现响应式布局，适应不同终端的开发。媒体查询的具体知识请见 CSS3新属性应用文档。</p>
<h3 id="你熟悉-SVG-样式的书写吗？"><a href="#你熟悉-SVG-样式的书写吗？" class="headerlink" title="你熟悉 SVG 样式的书写吗？"></a>你熟悉 SVG 样式的书写吗？</h3><h3 id="如何优化网页的打印样式？"><a href="#如何优化网页的打印样式？" class="headerlink" title="如何优化网页的打印样式？"></a>如何优化网页的打印样式？</h3><h4 id="添加打印样式"><a href="#添加打印样式" class="headerlink" title="添加打印样式"></a>添加打印样式</h4><p>为屏幕显示和打印分别准备一个css文件，如下所示：  </p>
<ul>
<li><p>用于屏幕显示的css：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/mainstylesheet.css&quot; media=&quot;screen&quot; /&gt;  
</code></pre></li>
<li><p>用于打印的css：  </p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/printstylesheet.css&quot; media=&quot;print&quot; /&gt;
</code></pre></li>
<li><p>import方式：</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    @import url(&quot;css/printstylesheet.css&quot;) print;
&lt;/style&gt;
</code></pre></li>
<li><p>直接把屏幕显示样式和打印样式写在一个css文件中：</p>
<pre><code>@media print {}{
   h1 {
     color: black;
   }
   h2 {}{
     color: gray;
   }
 }
     @media print里面的内容只对打印出来的内容有效，之外的内容就是屏幕显示的样式。
</code></pre></li>
<li><p>其他：<br>创建一个不指定媒体类型的样式表通常很有用（或者利用media=”all”）。当你准备好定义一些特别用<br>于打印的规则时，可以只创建一个单独的样式表，使任何在打印时看起来不好的样式都失效。使用这种方法的一个问题是必须确保打印机样式实际上确实覆盖了主样式表。可以使用！important.</p>
</li>
</ul>
<p>但打印样式表也应有些注意事项：    </p>
<ul>
<li>打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。  </li>
<li>最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。  </li>
<li>隐藏掉不必要的内容。（@print div{display:none;}）  </li>
<li>打印样式表中最好少用浮动属性，因为它们会消失。<br>如果想要知道打印样式表的效果如何，直接在浏览器上选择打印预览就可以了。  </li>
</ul>
<p>备注： 参考： <a href="http://blog.csdn.net/pangni/article/details/6224533" target="_blank" rel="external">http://blog.csdn.net/pangni/article/details/6224533</a></p>
<h3 id="在书写高效-CSS-时会有哪些问题需要考虑？"><a href="#在书写高效-CSS-时会有哪些问题需要考虑？" class="headerlink" title="在书写高效 CSS 时会有哪些问题需要考虑？"></a>在书写高效 CSS 时会有哪些问题需要考虑？</h3><ul>
<li>样式是：从右向左的解析一个选择器</li>
<li>ID最快，Universal最慢 有四种类型的key selector，解析速度由快到慢依次是：ID、class、tag和universal</li>
<li>不要tag-qualify （永远不要这样做 ul#main-navigation { } ID已经是唯一的，不需要Tag来标识，这样做会让选择器变慢。）</li>
<li>后代选择器最糟糕（换句话说，下面这个选择器是很低效的： html body ul li a { }）</li>
<li>想清楚你为什么这样写</li>
<li>CSS3的效率问题（CSS3选择器（比如 :nth-child）能够漂亮的定位我们想要的元素，又能保证我们的CSS整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。）</li>
<li>我们知道#ID速度是最快的，那么我们都用ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性</li>
</ul>
<h3 id="使用-CSS-预处理器的优缺点有哪些？"><a href="#使用-CSS-预处理器的优缺点有哪些？" class="headerlink" title="使用 CSS 预处理器的优缺点有哪些？"></a>使用 CSS 预处理器的优缺点有哪些？</h3><p><strong>缺点</strong>：简单来说CSS预处理器语言较CSS玩法变得更高级了，但同时降低了自己对最终代码的控制力。更致命的是提高了门槛，首先是上手门槛，其次是维护门槛，再来是团队整体水平和规范的门槛。这也造成了初学学习成本的昂贵。</p>
<p><strong>优点</strong>：用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。</p>
<h3 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h3><p>Webfonts (字体服务例如：Google Webfonts，Typekit 等等。)</p>
<h3 id="请解释浏览器是如何判断元素是否匹配某个-CSS-选择器？"><a href="#请解释浏览器是如何判断元素是否匹配某个-CSS-选择器？" class="headerlink" title="请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？"></a>请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？</h3><p>浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。</p>
<h3 id="请描述伪元素-pseudo-elements-及其用途"><a href="#请描述伪元素-pseudo-elements-及其用途" class="headerlink" title="请描述伪元素 (pseudo-elements) 及其用途"></a>请描述伪元素 (pseudo-elements) 及其用途</h3><p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。<br>伪元素用于创建一些不在文档树中的元素，并为其添加样式。</p>
<p><strong>区别：</strong>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素</p>
<p>参考： <a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="external">http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/</a></p>
<h3 id="请解释你对盒模型的理解，以及如何在-CSS-中告诉浏览器使用不同的盒模型来渲染你的布局？"><a href="#请解释你对盒模型的理解，以及如何在-CSS-中告诉浏览器使用不同的盒模型来渲染你的布局？" class="headerlink" title="请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局？"></a>请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局？</h3><p>盒子模型<strong>分为两类</strong>：<strong>W3C标准盒子模型</strong>和<strong>IE盒子模型</strong><br>这两者的关键<strong>区别</strong>就在于：  </p>
<ul>
<li>宽高的计算：W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border）<br>IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border）  </li>
</ul>
<p>各浏览器盒模型的组成结构是一致的，区别只是在”怪异模式”下宽度和高度的计算方式，而“标准模式”下则没有区别。</p>
<p>组成结构以宽度为例：总宽度=marginLeft+borderLeft+paddingLeft+contentWidth+paddingRight+borderRight+marginRight（W3C标准盒子模型）。页面在“怪异模式”下，css中为元素的width和height设置的值在标准浏览器和ie系列(ie9除外)里的代表的含义是不同的（IE盒子模型）。 </p>
<p> 因而解决兼容型为题最简洁和<strong>值得推荐的方式是：下述的第一条。</strong></p>
<ul>
<li>将页面设为“标准模式”。 添加对应的dtd标识，如： &lt;!DOCTYPE html&gt;  </li>
<li><p>使用hack或者在外面套上一层wrapper。 前提是页面处于“怪异模式”，“标准模式”不存在兼容性问题。 </p>
<pre><code>1、hack的方式
#box {  
width:100px !important; // ie9,ff,chrome,opera这样的标准浏览器
width:160px; //所有的浏览器；它的本意是只对不认识!important的设置。可是ie7、ie8也认识
+width:160px!important;//ie7
width:160px/0!important;//ie8
padding:0 10px;border:20px solid blue;margin:70px;  
}  

2、wrapper 
#box {  
width:100px;  
margin:70px;  
float:left;  
}  
.wrapper {  
padding:0 10px;border:20px solid blue;  
}  
</code></pre></li>
</ul>
<p>总结：使用“标准模式”即可实现兼容，不兼容只发生在“怪异模式”下。而且正常的页面基本上都选择前者，如果选择后者，麻烦不止于此，一些css技巧也将失灵，如将div居中：div {margin:0 auto;} </p>
<h3 id="请解释-box-sizing-border-box-的作用-并且说明使用它有什么好处？"><a href="#请解释-box-sizing-border-box-的作用-并且说明使用它有什么好处？" class="headerlink" title="请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？"></a>请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？</h3><p>设置他以后，相当于以怪异模式解析，border和padding全会在你设置的宽度内部，比如手机端设置两行并且的布局，宽度各为50%,如果不用这个属性，设置border后右边的div会下来错位，设置这个属性，宽度还是50%而不是50%+*px,两行可以并列显示</p>
<p>说到 IE 的 bug，在 IE6以前的版本中，IE对盒模型的解析出现一些问题，跟其它浏览器不同，将 border 与 padding 都包含在 width 之内。而另外一些浏览器则与它相反，是不包括border和padding的。对于IE浏览器，当我们设置 box-sizing: content-box; 时，浏览器对盒模型的解释遵从我们之前认识到的 W3C 标准，当它定义width和height时，它的宽度不包括border和padding；对于非IE浏览器，当我们设置box-sizing: border-box; 时，浏览器对盒模型的解释与 IE6之前的版本相同，当它定义width和height时，border和padding则是被包含在宽高之内的。内容的宽和高可以通过定义的“width”和 “height”减去相应方向的“padding”和“border”的宽度得到。内容的宽和高必须保证不能为负，必要时将自动增大该元素border box的尺寸以使其内容的宽或高最小为0。</p>
<p>好处：　</p>
<ul>
<li>　使用 * { box-sizing: border-box; }能够统一IE和非IE浏览器之间的差异。</li>
<li>　解决排版的问题，每个盒子之间排版时不用考虑padding和border的宽度计算</li>
</ul>
<h3 id="请罗列出你所知道的-display-属性的全部值"><a href="#请罗列出你所知道的-display-属性的全部值" class="headerlink" title="请罗列出你所知道的 display 属性的全部值?"></a>请罗列出你所知道的 display 属性的全部值?</h3><p>display 属性规定元素应该生成的框的类型。<br><img src="./display.png" alt="Alt display"></p>
<h3 id="请解释-inline-和-inline-block-的区别？"><a href="#请解释-inline-和-inline-block-的区别？" class="headerlink" title="请解释 inline 和 inline-block 的区别？"></a>请解释 inline 和 inline-block 的区别？</h3><p>都是display 属性规定元素应该生成的框的类型。但是block代表块级元素，元素前后都有换行符；inline是默认的样式，表示该元素被显示为内联元素，元素前后没有换行符号。也就是说，block元素通常被现实为独立的一块，会单独换一行；inline元素则前后不会产生换行，一系列inline元素都在一行内显示，直到该行排满。而inline-block代表行内块元素（css2.0新增）。</p>
<h4 id="display-block-1"><a href="#display-block-1" class="headerlink" title="display:block"></a>display:block</h4><ul>
<li><p>block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。</p>
</li>
<li><p>block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。</p>
</li>
<li><p>block元素可以设置margin和padding属性。</p>
</li>
</ul>
<h4 id="display-inline-1"><a href="#display-inline-1" class="headerlink" title="display:inline"></a>display:inline</h4><ul>
<li><p>inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。</p>
</li>
<li><p>inline元素设置width,height属性无效。</p>
</li>
<li><p>inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</p>
</li>
</ul>
<h4 id="display-inline-block-1"><a href="#display-inline-block-1" class="headerlink" title="display:inline-block"></a>display:inline-block</h4><p>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p>
<h3 id="请解释-relative、fixed、absolute-和-static-元素的区别"><a href="#请解释-relative、fixed、absolute-和-static-元素的区别" class="headerlink" title="请解释 relative、fixed、absolute 和 static 元素的区别?"></a>请解释 relative、fixed、absolute 和 static 元素的区别?</h3><p>各个属性的值：</p>
<ul>
<li><p>static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
</li>
<li><p>relative：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常位置进行定位。可通过z-index进行层次分级。</p>
</li>
<li><p>absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。</p>
</li>
<li><p>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。</p>
</li>
</ul>
<p><strong>relative和absolute进行对比分析：</strong></p>
<ul>
<li><p>relative。定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在。</p>
</li>
<li><p>absolute。定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不在存在。</p>
</li>
<li><p>fixed:定位为绝对定位，脱离正常文本流，相对于浏览器窗口进行定位</p>
</li>
</ul>
<p><strong>relative和absolute与fixed进行对比分析：</strong></p>
<ul>
<li>relative定位的层总是相对于其最近的父元素，无论其父元素是何种定位方式。</li>
<li>absolute定位的层总是相对于其最近的定义为absolute或relative的父层，而这个父层并不一定是其直接父层。如果其父层中都未定义absolute或relative，则其将相对body进行定位，</li>
<li>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
</ul>
<h3 id="CSS中字母-‘C’-的意思是叠层-Cascading-。请问在确定样式的过程中优先级是如何决定的-请举例-？如何有效使用此系统？"><a href="#CSS中字母-‘C’-的意思是叠层-Cascading-。请问在确定样式的过程中优先级是如何决定的-请举例-？如何有效使用此系统？" class="headerlink" title="CSS中字母 ‘C’ 的意思是叠层 (Cascading)。请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？"></a>CSS中字母 ‘C’ 的意思是叠层 (Cascading)。请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？</h3>]]></content>
    </entry>
    
  
  
</search>
